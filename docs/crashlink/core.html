<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>crashlink.core API documentation</title>
<meta name="description" content="Core bytecode format definitions …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>crashlink.core</code></h1>
</header>
<section id="section-intro">
<p>Core bytecode format definitions.</p>
<p>This module contains the definitions for HashLink bytecode structures, as well as the serialisation
and deserialisation methods for them. You probably don't need to use too much of this file directly,
besides Bytecode, Opcode, and Function. The decompiler will take care of a lot of abstraction for
you.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="crashlink.core.full_func_name"><code class="name flex">
<span>def <span class="ident">full_func_name</span></span>(<span>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>,<br>func: <a title="crashlink.core.Function" href="#crashlink.core.Function">Function</a> | <a title="crashlink.core.Native" href="#crashlink.core.Native">Native</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_func_name(code: Bytecode, func: Function | Native) -&gt; str:
    &#34;&#34;&#34;
    Generates a human-readable name for a function or native.
    &#34;&#34;&#34;
    proto = get_proto_for(code, func.findex.value)
    if proto:
        name = proto.name.resolve(code)
        for type in code.types:
            if type.kind.value == Type.TYPEDEFS.index(Obj):
                if not isinstance(type.definition, Obj):
                    continue
                obj_def: Obj = type.definition
                for fun in obj_def.protos:
                    if fun.findex.value == func.findex.value:
                        return f&#34;{obj_def.name.resolve(code)}.{name}&#34;
    else:
        name = &#34;&lt;none&gt;&#34;
        field = get_field_for(code, func.findex.value)
        if field:
            name = field.name.resolve(code)
            for type in code.types:
                if type.kind.value == Type.TYPEDEFS.index(Obj):
                    if not isinstance(type.definition, Obj):
                        continue
                    _obj_def: Obj = type.definition
                    fields = _obj_def.resolve_fields(code)
                    for binding in _obj_def.bindings:
                        if binding.findex.value == func.findex.value:
                            return f&#34;{_obj_def.name.resolve(code)}.{name}&#34;
    return name</code></pre>
</details>
<div class="desc"><p>Generates a human-readable name for a function or native.</p></div>
</dd>
<dt id="crashlink.core.get_field_for"><code class="name flex">
<span>def <span class="ident">get_field_for</span></span>(<span>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>,<br>idx: int) ‑> <a title="crashlink.core.Field" href="#crashlink.core.Field">Field</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_for(code: Bytecode, idx: int) -&gt; Optional[Field]:
    &#34;&#34;&#34;
    Gets the field for a standalone function index.
    &#34;&#34;&#34;
    for type in code.types:
        if type.kind.value == Type.TYPEDEFS.index(Obj):
            if not isinstance(type.definition, Obj):
                raise TypeError(f&#34;Expected Obj, got {type.definition}&#34;)
            definition: Obj = type.definition
            fields = definition.resolve_fields(code)
            for binding in definition.bindings:  # binding binds a field to a function
                if binding.findex.value == idx:
                    return fields[binding.field.value]
    return None</code></pre>
</details>
<div class="desc"><p>Gets the field for a standalone function index.</p></div>
</dd>
<dt id="crashlink.core.get_proto_for"><code class="name flex">
<span>def <span class="ident">get_proto_for</span></span>(<span>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>,<br>idx: int) ‑> <a title="crashlink.core.Proto" href="#crashlink.core.Proto">Proto</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proto_for(code: Bytecode, idx: int) -&gt; Optional[Proto]:
    &#34;&#34;&#34;
    Gets the proto for a standalone function index.
    &#34;&#34;&#34;
    for type in code.types:
        if type.kind.value == Type.TYPEDEFS.index(Obj):
            if not isinstance(type.definition, Obj):
                raise TypeError(f&#34;Expected Obj, got {type.definition}&#34;)
            definition: Obj = type.definition
            for proto in definition.protos:
                if proto.findex.value == idx:
                    return proto
    return None</code></pre>
</details>
<div class="desc"><p>Gets the proto for a standalone function index.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="crashlink.core.Abstract"><code class="flex name class">
<span>class <span class="ident">Abstract</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Abstract(TypeDef):
    &#34;&#34;&#34;
    Abstract class type.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.name = strRef()

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Abstract&#34;:
        self.name.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return self.name.serialise()</code></pre>
</details>
<div class="desc"><p>Abstract class type.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Abstract.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Abstract" href="#crashlink.core.Abstract">Abstract</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Abstract&#34;:
    self.name.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Abstract.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return self.name.serialise()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Array"><code class="flex name class">
<span>class <span class="ident">Array</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Array(_NoDataType):
    &#34;&#34;&#34;
    Array type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Array type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.Binding"><code class="flex name class">
<span>class <span class="ident">Binding</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Binding(Serialisable):
    &#34;&#34;&#34;
    Represents a binding of a field to a class.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.field = fieldRef()
        self.findex = fIndex()

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Binding&#34;:
        self.field.deserialise(f)
        self.findex.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join([self.field.serialise(), self.findex.serialise()])</code></pre>
</details>
<div class="desc"><p>Represents a binding of a field to a class.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Binding.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Binding" href="#crashlink.core.Binding">Binding</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Binding&#34;:
    self.field.deserialise(f)
    self.findex.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Binding.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join([self.field.serialise(), self.findex.serialise()])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Bool"><code class="flex name class">
<span>class <span class="ident">Bool</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bool(_NoDataType):
    &#34;&#34;&#34;
    Boolean type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Boolean type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.Bytecode"><code class="flex name class">
<span>class <span class="ident">Bytecode</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bytecode(Serialisable):
    &#34;&#34;&#34;
    The main bytecode class. To read a bytecode file, use the `from_path` class method.

    For more information about the overall structure, see [here](https://n3rdl0rd.github.io/ModDocCE/files/hlboot)
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.deserialised = False
        self.magic = RawData(3)
        self.version = SerialisableInt()
        self.version.length = 1
        self.flags = VarInt()
        self.has_debug_info: Optional[bool] = None
        self.nints = VarInt()
        self.nfloats = VarInt()
        self.nstrings = VarInt()
        self.nbytes: Optional[VarInt] = VarInt()
        self.ntypes = VarInt()
        self.nglobals = VarInt()
        self.nnatives = VarInt()
        self.nfunctions = VarInt()
        self.nconstants: Optional[VarInt] = VarInt()
        self.entrypoint = fIndex()

        self.ints: List[SerialisableInt] = []
        self.floats: List[SerialisableF64] = []
        self.strings = StringsBlock()
        self.bytes: Optional[BytesBlock] = BytesBlock()

        self.ndebugfiles: Optional[VarInt] = VarInt()
        self.debugfiles: Optional[StringsBlock] = StringsBlock()

        self.types: List[Type] = []
        self.global_types: List[tIndex] = []
        self.natives: List[Native] = []
        self.functions: List[Function] = []
        self.constants: List[Constant] = []

        self.initialized_globals: Dict[int, Any] = {}

        self.section_offsets: Dict[str, int] = {}

    def _find_magic(self, f: BinaryIO | BytesIO, magic: bytes = b&#34;HLB&#34;) -&gt; None:
        buffer_size = 1024
        offset = 0
        while True:
            chunk = f.read(buffer_size)
            if not chunk:
                raise NoMagic(&#34;Reached the end of file without finding magic bytes.&#34;)
            index = chunk.find(magic)
            if index != -1:
                f.seek(offset + index)
                dbg_print(f&#34;Found bytecode at {tell(f)}... &#34;, end=&#34;&#34;)
                return
            offset += buffer_size

    @classmethod
    def from_path(cls, path: str, search_magic: bool = True) -&gt; &#34;Bytecode&#34;:
        &#34;&#34;&#34;
        Create a new Bytecode instance from a file path.
        &#34;&#34;&#34;
        f = open(path, &#34;rb&#34;)
        instance = cls().deserialise(f, search_magic=search_magic)
        f.close()
        return instance

    @classmethod
    def from_bytes(cls, data: bytes, search_magic: bool = True) -&gt; &#34;Bytecode&#34;:
        &#34;&#34;&#34;
        Create a new Bytecode instance from a `bytes` object.
        &#34;&#34;&#34;
        f = BytesIO(data)
        instance = cls().deserialise(f, search_magic=search_magic)
        f.close()
        return instance

    @classmethod
    def create_empty(cls, version: int = 4, no_extra_types: bool = False) -&gt; &#34;Bytecode&#34;:
        &#34;&#34;&#34;
        Creates an empty HashLink bytecode object, ideal for adding custom functions or code to for testing. By default, contains the following types already defined:

        - t@0: Void
        - t@1: I32
        - t@2: F64
        - t@3: Bool

        Optionally, it can be created with only the Void type defined by passing `no_extra_types=True`. Note that for the bytecode to be valid and executable, there must be at least a single function, and this function must have a valid return type, meaning that the bytecode must contain **at least** 1 type.
        &#34;&#34;&#34;
        instance = Bytecode()
        instance.magic.value = b&#34;HLB&#34;
        instance.version.value = version
        instance.has_debug_info = False

        void = Type()
        void.kind.value = 0  # Void (_NoDataType)
        void.definition = Void()

        if not no_extra_types:
            i32 = Type()
            i32.kind.value = 3
            i32.definition = I32()

            f64 = Type()
            f64.kind.value = 6
            f64.definition = F64()

            bool_t = Type()
            bool_t.kind.value = 7
            bool_t.definition = Bool()

        instance.types.append(void)

        if not no_extra_types:
            instance.types.append(i32)
            instance.types.append(f64)
            instance.types.append(bool_t)

        instance.set_meta()

        return instance

    def deserialise(self, f: BinaryIO | BytesIO, search_magic: bool = True, init_globals: bool = True) -&gt; &#34;Bytecode&#34;:
        &#34;&#34;&#34;
        Deserialise the bytecode in-place from an open binary file handle or a BytesIO object. By default will search for the bytecode magic (b&#39;HLB&#39;) anywhere in the file, pass `search_magic=False` to disable.
        &#34;&#34;&#34;
        start_time = datetime.now()
        dbg_print(&#34;---- Deserialise ----&#34;)
        if search_magic:
            dbg_print(&#34;Searching for magic...&#34;)
            self._find_magic(f)
        self.track_section(f, &#34;magic&#34;)
        self.magic.deserialise(f)
        assert self.magic.value == b&#34;HLB&#34;, &#34;Incorrect magic found!&#34;
        self.track_section(f, &#34;version&#34;)
        self.version.deserialise(f, length=1)
        dbg_print(f&#34;with version {self.version.value}... &#34;, end=&#34;&#34;)
        self.track_section(f, &#34;flags&#34;)
        self.flags.deserialise(f)
        self.has_debug_info = bool(self.flags.value &amp; 1)
        dbg_print(f&#34;debug info: {self.has_debug_info}. &#34;)
        self.track_section(f, &#34;nints&#34;)
        self.nints.deserialise(f)
        self.track_section(f, &#34;nfloats&#34;)
        self.nfloats.deserialise(f)
        self.track_section(f, &#34;nstrings&#34;)
        self.nstrings.deserialise(f)

        if self.version.value &gt;= 5 and self.nbytes:
            dbg_print(f&#34;Found nbytes (version &gt;= 5) at {tell(f)}&#34;)
            self.track_section(f, &#34;nbytes&#34;)
            self.nbytes.deserialise(f)
        else:
            self.nbytes = None

        self.track_section(f, &#34;ntypes&#34;)
        self.ntypes.deserialise(f)
        self.track_section(f, &#34;nglobals&#34;)
        self.nglobals.deserialise(f)
        self.track_section(f, &#34;nnatives&#34;)
        self.nnatives.deserialise(f)
        self.track_section(f, &#34;nfunctions&#34;)
        self.nfunctions.deserialise(f)

        if self.version.value &gt;= 4 and self.nconstants:
            dbg_print(f&#34;Found nconstants (version &gt;= 4) at {tell(f)}&#34;)
            self.track_section(f, &#34;nconstants&#34;)
            self.nconstants.deserialise(f)
        else:
            self.nconstants = None

        self.track_section(f, &#34;entrypoint&#34;)
        self.entrypoint.deserialise(f)
        dbg_print(f&#34;Entrypoint: f@{self.entrypoint.value}&#34;)

        self.track_section(f, &#34;ints&#34;)
        for i in range(self.nints.value):
            self.track_section(f, f&#34;int {i}&#34;)
            self.ints.append(SerialisableInt().deserialise(f, length=4))

        self.track_section(f, &#34;floats&#34;)
        for i in range(self.nfloats.value):
            self.track_section(f, f&#34;float {i}&#34;)
            self.floats.append(SerialisableF64().deserialise(f))

        dbg_print(f&#34;Strings section starts at {tell(f)}&#34;)
        self.track_section(f, &#34;strings&#34;)
        self.strings.deserialise(f, self.nstrings.value)
        dbg_print(f&#34;Strings section ends at {tell(f)}&#34;)
        assert self.nstrings.value == len(self.strings.value), &#34;nstrings and len of strings don&#39;t match!&#34;

        if self.version.value &gt;= 5 and self.bytes and self.nbytes:
            dbg_print(&#34;Deserialising bytes... &gt;=5&#34;)
            self.track_section(f, &#34;bytes&#34;)
            self.bytes.deserialise(f, self.nbytes.value)
        else:
            self.bytes = None

        if self.has_debug_info and self.ndebugfiles and self.debugfiles:
            dbg_print(f&#34;Deserialising debug files... (at {tell(f)})&#34;)
            self.track_section(f, &#34;ndebugfiles&#34;)
            self.ndebugfiles.deserialise(f)
            dbg_print(f&#34;Number of debug files: {self.ndebugfiles.value}&#34;)
            self.track_section(f, &#34;debugfiles&#34;)
            self.debugfiles.deserialise(f, self.ndebugfiles.value)
        else:
            self.ndebugfiles = None
            self.debugfiles = None

        dbg_print(f&#34;Starting main blobs at {tell(f)}&#34;)
        dbg_print(f&#34;Types starting at {tell(f)}&#34;)
        self.track_section(f, &#34;types&#34;)
        for i in range(self.ntypes.value):
            self.track_section(f, f&#34;type {i}&#34;)
            self.types.append(Type().deserialise(f))
        dbg_print(f&#34;Globals starting at {tell(f)}&#34;)
        self.track_section(f, &#34;globals&#34;)
        for i in range(self.nglobals.value):
            self.track_section(f, f&#34;global {i}&#34;)
            self.global_types.append(tIndex().deserialise(f))
        dbg_print(f&#34;Natives starting at {tell(f)}&#34;)
        self.track_section(f, &#34;natives&#34;)
        for i in range(self.nnatives.value):
            self.track_section(f, f&#34;native {i}&#34;)
            self.natives.append(Native().deserialise(f))
        dbg_print(f&#34;Functions starting at {tell(f)}&#34;)
        self.track_section(f, &#34;functions&#34;)
        if not USE_TQDM or self.nfunctions.value &lt; 1000:
            for i in range(self.nfunctions.value):
                self.track_section(f, f&#34;function {i}&#34;)
                self.functions.append(Function().deserialise(f, self.has_debug_info, self.version.value))
        else:
            for i in tqdm(range(self.nfunctions.value)):
                self.track_section(f, f&#34;function {i}&#34;)
                self.functions.append(Function().deserialise(f, self.has_debug_info, self.version.value))
        if self.nconstants is not None:
            dbg_print(f&#34;Constants starting at {tell(f)}&#34;)
            self.track_section(f, &#34;constants&#34;)
            for i in range(self.nconstants.value):
                self.track_section(f, f&#34;constant {i}&#34;)
                self.constants.append(Constant().deserialise(f))
        dbg_print(f&#34;Bytecode end at {tell(f)}.&#34;)
        self.deserialised = True
        if init_globals:
            dbg_print(&#34;Initializing globals...&#34;)
            self.init_globals()
        dbg_print(f&#34;{(datetime.now() - start_time).total_seconds()}s elapsed.&#34;)
        return self

    def init_globals(self) -&gt; None:
        &#34;&#34;&#34;
        Internal method to initialize global instances of objects.
        &#34;&#34;&#34;
        final: Dict[int, Any] = {}
        for const in self.constants:
            res: Dict[str, Any] = {}
            obj = const._global.resolve(self).definition
            if not isinstance(obj, Obj):
                dbg_print(&#34;WARNING: Skipping non-Obj constant.&#34;)
                continue
            obj_fields = obj.resolve_fields(self)
            for i, field in enumerate(const.fields):
                # Field has:
                # - name: strRef
                # - type: tIndex
                # we need to use the type to know how to resolve the const ref to the actual value
                typ = obj_fields[i].type.resolve(self).definition
                name = obj_fields[i].name.resolve(self)
                if isinstance(typ, I32) or isinstance(typ, U8) or isinstance(typ, U16) or isinstance(typ, I64):
                    res[name] = self.ints[field.value].value
                elif isinstance(typ, F32) or isinstance(typ, F64):
                    res[name] = self.floats[field.value].value
                elif isinstance(typ, Bytes):
                    res[name] = self.strings.value[field.value]
                else:
                    res[name] = field.value
            final[const._global.value] = res
        assert len(final) == len(
            self.constants
        ), &#34;Not all constants were resolved! This is often due to bad DebugInfo blocks causing buffer overrun, try passing -N to troubleshoot.&#34;
        self.initialized_globals = final

    def fn(self, findex: int, native: bool = True) -&gt; Function | Native:
        &#34;&#34;&#34;
        Shorthand to to get a Function or a Native by its fIndex.
        &#34;&#34;&#34;
        for f in self.functions:
            if f.findex.value == findex:
                return f
        if native:
            for n in self.natives:
                if n.findex.value == findex:
                    return n
        raise ValueError(f&#34;Function {findex} not found!&#34;)

    def t(self, tindex: int) -&gt; Type:
        &#34;&#34;&#34;
        Shorthand to get a Type by its index. Equivalent to code.types[tindex]
        &#34;&#34;&#34;
        return self.types[tindex]

    def g(self, gindex: int) -&gt; Type:
        &#34;&#34;&#34;
        Shorthand to get a global&#39;s type by gIndex.
        &#34;&#34;&#34;
        for g in self.global_types:
            if g.value == gindex:
                return g.resolve(self)
        raise ValueError(f&#34;Global {gindex} not found!&#34;)

    def const_str(self, gindex: int) -&gt; str:
        &#34;&#34;&#34;
        Gets the value of an initialized global constant `String`.
        &#34;&#34;&#34;
        # TODO: is this overcomplicated?
        if gindex not in self.initialized_globals:
            if gindex &lt; 0 or gindex &gt;= len(self.global_types):
                raise ValueError(f&#34;Global {gindex} not found!&#34;)
            raise ValueError(f&#34;Global {gindex} does not have a constant value!&#34;)
        obj = self.global_types[gindex].resolve(self).definition
        if not isinstance(obj, Obj):
            raise TypeError(f&#34;Global {gindex} is not an object!&#34;)
        if not obj.name.resolve(self) == &#34;String&#34;:
            raise TypeError(f&#34;Global {gindex} is not a string!&#34;)
        obj_fields = obj.resolve_fields(self)
        if len(obj_fields) != 2:
            raise ValueError(f&#34;Global {gindex} seems malformed!&#34;)
        res = self.initialized_globals[gindex][obj_fields[0].name.resolve(self)]
        if not isinstance(res, str):
            raise TypeError(f&#34;This should never happen!&#34;)
        return res

    def serialise(self, auto_set_meta: bool = True) -&gt; bytes:
        &#34;&#34;&#34;
        Serialise the bytecode to a `bytes` object.
        &#34;&#34;&#34;
        start_time = datetime.now()
        dbg_print(&#34;---- Serialise ----&#34;)
        if auto_set_meta:
            dbg_print(&#34;Setting meta...&#34;)
            self.set_meta()
        res = b&#34;&#34;.join(
            [
                self.magic.serialise(),
                self.version.serialise(),
                self.flags.serialise(),
                self.nints.serialise(),
                self.nfloats.serialise(),
                self.nstrings.serialise(),
            ]
        )
        dbg_print(f&#34;VarInt block 1 at {hex(len(res))}&#34;)
        if self.version.value &gt;= 5 and self.nbytes:
            res += self.nbytes.serialise()
        res += b&#34;&#34;.join(
            [
                self.ntypes.serialise(),
                self.nglobals.serialise(),
                self.nnatives.serialise(),
                self.nfunctions.serialise(),
            ]
        )
        dbg_print(f&#34;VarInt block 2 at {hex(len(res))}&#34;)
        if self.version.value &gt;= 4 and self.nconstants:
            res += self.nconstants.serialise()
        res += self.entrypoint.serialise()
        res += b&#34;&#34;.join([i.serialise() for i in self.ints])
        res += b&#34;&#34;.join([f.serialise() for f in self.floats])
        res += self.strings.serialise()
        if self.version.value &gt;= 5 and self.bytes:
            res += self.bytes.serialise()
        if self.has_debug_info and self.ndebugfiles and self.debugfiles:
            res += b&#34;&#34;.join([self.ndebugfiles.serialise(), self.debugfiles.serialise()])
        res += b&#34;&#34;.join(
            [
                b&#34;&#34;.join([typ.serialise() for typ in self.types]),
                b&#34;&#34;.join([typ.serialise() for typ in self.global_types]),
                b&#34;&#34;.join([native.serialise() for native in self.natives]),
            ]
        )
        if USE_TQDM:
            res += b&#34;&#34;.join([func.serialise() for func in tqdm(self.functions)])
        else:
            res += b&#34;&#34;.join([func.serialise() for func in self.functions])
        res += b&#34;&#34;.join([constant.serialise() for constant in self.constants])
        dbg_print(f&#34;Final size: {hex(len(res))}&#34;)
        dbg_print(f&#34;{(datetime.now() - start_time).total_seconds()}s elapsed.&#34;)
        return res

    def set_meta(self) -&gt; None:
        &#34;&#34;&#34;
        Sets bytecode metadata automatically.
        &#34;&#34;&#34;
        self.flags.value = 1 if self.has_debug_info else 0
        self.nints.value = len(self.ints)
        self.nfloats.value = len(self.floats)
        self.nstrings.value = len(self.strings.value)
        if self.version.value &gt;= 5 and self.bytes and self.nbytes:
            self.nbytes.value = len(self.bytes.value)
        self.ntypes.value = len(self.types)
        self.nglobals.value = len(self.global_types)
        self.nnatives.value = len(self.natives)
        self.nfunctions.value = len(self.functions)
        if self.version.value &gt;= 4 and self.nconstants:
            self.nconstants.value = len(self.constants)
        if self.has_debug_info and self.ndebugfiles and self.debugfiles:
            self.ndebugfiles.value = len(self.debugfiles.value)

    def repair(self) -&gt; None:
        &#34;&#34;&#34;
        Alternate notation for code.set_meta() for the purpose of clarity.
        &#34;&#34;&#34;
        self.set_meta()

    def get_test_main(self) -&gt; Function:
        for f in self.functions:
            if full_func_name(self, f).endswith(&#34;main&#34;):
                return f
        raise ValueError(&#34;No main function found!&#34;)

    def is_ok(self) -&gt; bool:
        &#34;&#34;&#34;
        Runs a set of basic sanity checks to make sure the bytecode is correct-ish.
        &#34;&#34;&#34;

        def fail(msg: str) -&gt; None:
            print(f&#34;--- FAILED CHECK ---\n{msg}&#34;)

        if len(self.ints) != self.nints.value:
            fail(&#34;ints != nints&#34;)
            return False

        if len(self.floats) != self.nfloats.value:
            fail(&#34;floats != nfloats&#34;)
            return False

        if len(self.strings.value) != self.nstrings.value:
            fail(&#34;strings != nstrings&#34;)
            print(len(self.strings.value), self.nstrings.value)
            return False

        if self.version.value &gt;= 5:
            if self.nbytes is None or self.bytes is None:
                fail(&#34;nbytes or bytes is None and version &gt;= 5&#34;)
                return False
            if len(self.bytes.value) != self.nbytes.value:
                fail(&#34;bytes != nbytes&#34;)
                return False

        if len(self.types) != self.ntypes.value:
            fail(&#34;types != ntypes&#34;)
            return False

        if len(self.global_types) != self.nglobals.value:
            fail(&#34;globals != nglobals&#34;)
            return False

        if len(self.natives) != self.nnatives.value:
            fail(&#34;natives != nnatives&#34;)
            return False

        if len(self.functions) != self.nfunctions.value:
            fail(&#34;functions != nfunctions&#34;)
            return False

        if self.version.value &gt;= 4:
            if self.nconstants is None:
                fail(&#34;nconstants is None and version &gt;= 4&#34;)
                return False
            if len(self.constants) != self.nconstants.value:
                fail(&#34;constants != nconstants&#34;)
                return False

        if self.has_debug_info:
            if self.ndebugfiles is None or self.debugfiles is None:
                fail(&#34;ndebugfiles or debugfiles is None and has_debug_info&#34;)
                return False
            if len(self.debugfiles.value) != self.ndebugfiles.value:
                fail(&#34;debugfiles != ndebugfiles&#34;)
                return False

        return True

    def track_section(self, f: BinaryIO | BytesIO, section_name: str) -&gt; None:
        &#34;&#34;&#34;
        Internal helper function to denote the location of a data section at a given offset.
        &#34;&#34;&#34;
        self.section_offsets[section_name] = f.tell()

    def section_at(self, offset: int) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the name of the bytecode data section at the offset.
        &#34;&#34;&#34;
        # returns the name of the section at the offset:
        # if the offset is after a section start and before the next section start, it&#39;s still in the first section
        for section_name, section_offset in list(reversed(self.section_offsets.items())):
            if offset &gt;= section_offset:
                return section_name
        return None

    def add_string(self, string: str) -&gt; strRef:
        &#34;&#34;&#34;
        Adds a string to the bytecode&#39;s string block and returns a reference to it.
        &#34;&#34;&#34;
        return strRef(self.strings.find_or_add(string))

    def next_free_findex(self) -&gt; fIndex:
        &#34;&#34;&#34;
        Find the next available fIndex that is not already used by any function or native.
        &#34;&#34;&#34;
        used_indexes = set()
        for function in self.functions:
            used_indexes.add(function.findex.value)
        for native in self.natives:
            used_indexes.add(native.findex.value)

        index = 0
        while index in used_indexes:
            index += 1

        return fIndex(index)

    def find_prim_type(self, kind: Type.Kind) -&gt; tIndex:
        &#34;&#34;&#34;
        Finds the index of a primitive type in the bytecode.
        &#34;&#34;&#34;
        assert kind.value in [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            12,
            13,
            16,
        ], f&#34;This method can only find primitive types! Got: {kind}&#34;
        for i, typ in enumerate(self.types):
            if typ.kind.value == kind.value:
                return tIndex(i)
        raise ValueError(f&#34;Primitive type {kind} not found!&#34;)

    def add_type(self, typ: Type) -&gt; tIndex:
        &#34;&#34;&#34;
        Adds a type and returns its tIndex.
        &#34;&#34;&#34;
        self.types.append(typ)
        return tIndex(len(self.types) - 1)</code></pre>
</details>
<div class="desc"><p>The main bytecode class. To read a bytecode file, use the <code>from_path</code> class method.</p>
<p>For more information about the overall structure, see <a href="https://n3rdl0rd.github.io/ModDocCE/files/hlboot">here</a></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="crashlink.core.Bytecode.create_empty"><code class="name flex">
<span>def <span class="ident">create_empty</span></span>(<span>version: int = 4, no_extra_types: bool = False) ‑> <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an empty HashLink bytecode object, ideal for adding custom functions or code to for testing. By default, contains the following types already defined:</p>
<ul>
<li>t@0: Void</li>
<li>t@1: I32</li>
<li>t@2: F64</li>
<li>t@3: Bool</li>
</ul>
<p>Optionally, it can be created with only the Void type defined by passing <code>no_extra_types=True</code>. Note that for the bytecode to be valid and executable, there must be at least a single function, and this function must have a valid return type, meaning that the bytecode must contain <strong>at least</strong> 1 type.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.from_bytes"><code class="name flex">
<span>def <span class="ident">from_bytes</span></span>(<span>data: bytes, search_magic: bool = True) ‑> <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Bytecode instance from a <code>bytes</code> object.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.from_path"><code class="name flex">
<span>def <span class="ident">from_path</span></span>(<span>path: str, search_magic: bool = True) ‑> <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Bytecode instance from a file path.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Bytecode.add_string"><code class="name flex">
<span>def <span class="ident">add_string</span></span>(<span>self, string: str) ‑> <a title="crashlink.core.strRef" href="#crashlink.core.strRef">strRef</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_string(self, string: str) -&gt; strRef:
    &#34;&#34;&#34;
    Adds a string to the bytecode&#39;s string block and returns a reference to it.
    &#34;&#34;&#34;
    return strRef(self.strings.find_or_add(string))</code></pre>
</details>
<div class="desc"><p>Adds a string to the bytecode's string block and returns a reference to it.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.add_type"><code class="name flex">
<span>def <span class="ident">add_type</span></span>(<span>self,<br>typ: <a title="crashlink.core.Type" href="#crashlink.core.Type">Type</a>) ‑> <a title="crashlink.core.tIndex" href="#crashlink.core.tIndex">tIndex</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_type(self, typ: Type) -&gt; tIndex:
    &#34;&#34;&#34;
    Adds a type and returns its tIndex.
    &#34;&#34;&#34;
    self.types.append(typ)
    return tIndex(len(self.types) - 1)</code></pre>
</details>
<div class="desc"><p>Adds a type and returns its tIndex.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.const_str"><code class="name flex">
<span>def <span class="ident">const_str</span></span>(<span>self, gindex: int) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def const_str(self, gindex: int) -&gt; str:
    &#34;&#34;&#34;
    Gets the value of an initialized global constant `String`.
    &#34;&#34;&#34;
    # TODO: is this overcomplicated?
    if gindex not in self.initialized_globals:
        if gindex &lt; 0 or gindex &gt;= len(self.global_types):
            raise ValueError(f&#34;Global {gindex} not found!&#34;)
        raise ValueError(f&#34;Global {gindex} does not have a constant value!&#34;)
    obj = self.global_types[gindex].resolve(self).definition
    if not isinstance(obj, Obj):
        raise TypeError(f&#34;Global {gindex} is not an object!&#34;)
    if not obj.name.resolve(self) == &#34;String&#34;:
        raise TypeError(f&#34;Global {gindex} is not a string!&#34;)
    obj_fields = obj.resolve_fields(self)
    if len(obj_fields) != 2:
        raise ValueError(f&#34;Global {gindex} seems malformed!&#34;)
    res = self.initialized_globals[gindex][obj_fields[0].name.resolve(self)]
    if not isinstance(res, str):
        raise TypeError(f&#34;This should never happen!&#34;)
    return res</code></pre>
</details>
<div class="desc"><p>Gets the value of an initialized global constant <code>String</code>.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self,<br>f: typing.BinaryIO | _io.BytesIO,<br>search_magic: bool = True,<br>init_globals: bool = True) ‑> <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO, search_magic: bool = True, init_globals: bool = True) -&gt; &#34;Bytecode&#34;:
    &#34;&#34;&#34;
    Deserialise the bytecode in-place from an open binary file handle or a BytesIO object. By default will search for the bytecode magic (b&#39;HLB&#39;) anywhere in the file, pass `search_magic=False` to disable.
    &#34;&#34;&#34;
    start_time = datetime.now()
    dbg_print(&#34;---- Deserialise ----&#34;)
    if search_magic:
        dbg_print(&#34;Searching for magic...&#34;)
        self._find_magic(f)
    self.track_section(f, &#34;magic&#34;)
    self.magic.deserialise(f)
    assert self.magic.value == b&#34;HLB&#34;, &#34;Incorrect magic found!&#34;
    self.track_section(f, &#34;version&#34;)
    self.version.deserialise(f, length=1)
    dbg_print(f&#34;with version {self.version.value}... &#34;, end=&#34;&#34;)
    self.track_section(f, &#34;flags&#34;)
    self.flags.deserialise(f)
    self.has_debug_info = bool(self.flags.value &amp; 1)
    dbg_print(f&#34;debug info: {self.has_debug_info}. &#34;)
    self.track_section(f, &#34;nints&#34;)
    self.nints.deserialise(f)
    self.track_section(f, &#34;nfloats&#34;)
    self.nfloats.deserialise(f)
    self.track_section(f, &#34;nstrings&#34;)
    self.nstrings.deserialise(f)

    if self.version.value &gt;= 5 and self.nbytes:
        dbg_print(f&#34;Found nbytes (version &gt;= 5) at {tell(f)}&#34;)
        self.track_section(f, &#34;nbytes&#34;)
        self.nbytes.deserialise(f)
    else:
        self.nbytes = None

    self.track_section(f, &#34;ntypes&#34;)
    self.ntypes.deserialise(f)
    self.track_section(f, &#34;nglobals&#34;)
    self.nglobals.deserialise(f)
    self.track_section(f, &#34;nnatives&#34;)
    self.nnatives.deserialise(f)
    self.track_section(f, &#34;nfunctions&#34;)
    self.nfunctions.deserialise(f)

    if self.version.value &gt;= 4 and self.nconstants:
        dbg_print(f&#34;Found nconstants (version &gt;= 4) at {tell(f)}&#34;)
        self.track_section(f, &#34;nconstants&#34;)
        self.nconstants.deserialise(f)
    else:
        self.nconstants = None

    self.track_section(f, &#34;entrypoint&#34;)
    self.entrypoint.deserialise(f)
    dbg_print(f&#34;Entrypoint: f@{self.entrypoint.value}&#34;)

    self.track_section(f, &#34;ints&#34;)
    for i in range(self.nints.value):
        self.track_section(f, f&#34;int {i}&#34;)
        self.ints.append(SerialisableInt().deserialise(f, length=4))

    self.track_section(f, &#34;floats&#34;)
    for i in range(self.nfloats.value):
        self.track_section(f, f&#34;float {i}&#34;)
        self.floats.append(SerialisableF64().deserialise(f))

    dbg_print(f&#34;Strings section starts at {tell(f)}&#34;)
    self.track_section(f, &#34;strings&#34;)
    self.strings.deserialise(f, self.nstrings.value)
    dbg_print(f&#34;Strings section ends at {tell(f)}&#34;)
    assert self.nstrings.value == len(self.strings.value), &#34;nstrings and len of strings don&#39;t match!&#34;

    if self.version.value &gt;= 5 and self.bytes and self.nbytes:
        dbg_print(&#34;Deserialising bytes... &gt;=5&#34;)
        self.track_section(f, &#34;bytes&#34;)
        self.bytes.deserialise(f, self.nbytes.value)
    else:
        self.bytes = None

    if self.has_debug_info and self.ndebugfiles and self.debugfiles:
        dbg_print(f&#34;Deserialising debug files... (at {tell(f)})&#34;)
        self.track_section(f, &#34;ndebugfiles&#34;)
        self.ndebugfiles.deserialise(f)
        dbg_print(f&#34;Number of debug files: {self.ndebugfiles.value}&#34;)
        self.track_section(f, &#34;debugfiles&#34;)
        self.debugfiles.deserialise(f, self.ndebugfiles.value)
    else:
        self.ndebugfiles = None
        self.debugfiles = None

    dbg_print(f&#34;Starting main blobs at {tell(f)}&#34;)
    dbg_print(f&#34;Types starting at {tell(f)}&#34;)
    self.track_section(f, &#34;types&#34;)
    for i in range(self.ntypes.value):
        self.track_section(f, f&#34;type {i}&#34;)
        self.types.append(Type().deserialise(f))
    dbg_print(f&#34;Globals starting at {tell(f)}&#34;)
    self.track_section(f, &#34;globals&#34;)
    for i in range(self.nglobals.value):
        self.track_section(f, f&#34;global {i}&#34;)
        self.global_types.append(tIndex().deserialise(f))
    dbg_print(f&#34;Natives starting at {tell(f)}&#34;)
    self.track_section(f, &#34;natives&#34;)
    for i in range(self.nnatives.value):
        self.track_section(f, f&#34;native {i}&#34;)
        self.natives.append(Native().deserialise(f))
    dbg_print(f&#34;Functions starting at {tell(f)}&#34;)
    self.track_section(f, &#34;functions&#34;)
    if not USE_TQDM or self.nfunctions.value &lt; 1000:
        for i in range(self.nfunctions.value):
            self.track_section(f, f&#34;function {i}&#34;)
            self.functions.append(Function().deserialise(f, self.has_debug_info, self.version.value))
    else:
        for i in tqdm(range(self.nfunctions.value)):
            self.track_section(f, f&#34;function {i}&#34;)
            self.functions.append(Function().deserialise(f, self.has_debug_info, self.version.value))
    if self.nconstants is not None:
        dbg_print(f&#34;Constants starting at {tell(f)}&#34;)
        self.track_section(f, &#34;constants&#34;)
        for i in range(self.nconstants.value):
            self.track_section(f, f&#34;constant {i}&#34;)
            self.constants.append(Constant().deserialise(f))
    dbg_print(f&#34;Bytecode end at {tell(f)}.&#34;)
    self.deserialised = True
    if init_globals:
        dbg_print(&#34;Initializing globals...&#34;)
        self.init_globals()
    dbg_print(f&#34;{(datetime.now() - start_time).total_seconds()}s elapsed.&#34;)
    return self</code></pre>
</details>
<div class="desc"><p>Deserialise the bytecode in-place from an open binary file handle or a BytesIO object. By default will search for the bytecode magic (b'HLB') anywhere in the file, pass <code>search_magic=False</code> to disable.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.find_prim_type"><code class="name flex">
<span>def <span class="ident">find_prim_type</span></span>(<span>self,<br>kind: <a title="crashlink.core.Type.Kind" href="#crashlink.core.Type.Kind">Type.Kind</a>) ‑> <a title="crashlink.core.tIndex" href="#crashlink.core.tIndex">tIndex</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_prim_type(self, kind: Type.Kind) -&gt; tIndex:
    &#34;&#34;&#34;
    Finds the index of a primitive type in the bytecode.
    &#34;&#34;&#34;
    assert kind.value in [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        12,
        13,
        16,
    ], f&#34;This method can only find primitive types! Got: {kind}&#34;
    for i, typ in enumerate(self.types):
        if typ.kind.value == kind.value:
            return tIndex(i)
    raise ValueError(f&#34;Primitive type {kind} not found!&#34;)</code></pre>
</details>
<div class="desc"><p>Finds the index of a primitive type in the bytecode.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.fn"><code class="name flex">
<span>def <span class="ident">fn</span></span>(<span>self, findex: int, native: bool = True) ‑> <a title="crashlink.core.Function" href="#crashlink.core.Function">Function</a> | <a title="crashlink.core.Native" href="#crashlink.core.Native">Native</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fn(self, findex: int, native: bool = True) -&gt; Function | Native:
    &#34;&#34;&#34;
    Shorthand to to get a Function or a Native by its fIndex.
    &#34;&#34;&#34;
    for f in self.functions:
        if f.findex.value == findex:
            return f
    if native:
        for n in self.natives:
            if n.findex.value == findex:
                return n
    raise ValueError(f&#34;Function {findex} not found!&#34;)</code></pre>
</details>
<div class="desc"><p>Shorthand to to get a Function or a Native by its fIndex.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.g"><code class="name flex">
<span>def <span class="ident">g</span></span>(<span>self, gindex: int) ‑> <a title="crashlink.core.Type" href="#crashlink.core.Type">Type</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(self, gindex: int) -&gt; Type:
    &#34;&#34;&#34;
    Shorthand to get a global&#39;s type by gIndex.
    &#34;&#34;&#34;
    for g in self.global_types:
        if g.value == gindex:
            return g.resolve(self)
    raise ValueError(f&#34;Global {gindex} not found!&#34;)</code></pre>
</details>
<div class="desc"><p>Shorthand to get a global's type by gIndex.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.get_test_main"><code class="name flex">
<span>def <span class="ident">get_test_main</span></span>(<span>self) ‑> <a title="crashlink.core.Function" href="#crashlink.core.Function">Function</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_test_main(self) -&gt; Function:
    for f in self.functions:
        if full_func_name(self, f).endswith(&#34;main&#34;):
            return f
    raise ValueError(&#34;No main function found!&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Bytecode.init_globals"><code class="name flex">
<span>def <span class="ident">init_globals</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_globals(self) -&gt; None:
    &#34;&#34;&#34;
    Internal method to initialize global instances of objects.
    &#34;&#34;&#34;
    final: Dict[int, Any] = {}
    for const in self.constants:
        res: Dict[str, Any] = {}
        obj = const._global.resolve(self).definition
        if not isinstance(obj, Obj):
            dbg_print(&#34;WARNING: Skipping non-Obj constant.&#34;)
            continue
        obj_fields = obj.resolve_fields(self)
        for i, field in enumerate(const.fields):
            # Field has:
            # - name: strRef
            # - type: tIndex
            # we need to use the type to know how to resolve the const ref to the actual value
            typ = obj_fields[i].type.resolve(self).definition
            name = obj_fields[i].name.resolve(self)
            if isinstance(typ, I32) or isinstance(typ, U8) or isinstance(typ, U16) or isinstance(typ, I64):
                res[name] = self.ints[field.value].value
            elif isinstance(typ, F32) or isinstance(typ, F64):
                res[name] = self.floats[field.value].value
            elif isinstance(typ, Bytes):
                res[name] = self.strings.value[field.value]
            else:
                res[name] = field.value
        final[const._global.value] = res
    assert len(final) == len(
        self.constants
    ), &#34;Not all constants were resolved! This is often due to bad DebugInfo blocks causing buffer overrun, try passing -N to troubleshoot.&#34;
    self.initialized_globals = final</code></pre>
</details>
<div class="desc"><p>Internal method to initialize global instances of objects.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.is_ok"><code class="name flex">
<span>def <span class="ident">is_ok</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ok(self) -&gt; bool:
    &#34;&#34;&#34;
    Runs a set of basic sanity checks to make sure the bytecode is correct-ish.
    &#34;&#34;&#34;

    def fail(msg: str) -&gt; None:
        print(f&#34;--- FAILED CHECK ---\n{msg}&#34;)

    if len(self.ints) != self.nints.value:
        fail(&#34;ints != nints&#34;)
        return False

    if len(self.floats) != self.nfloats.value:
        fail(&#34;floats != nfloats&#34;)
        return False

    if len(self.strings.value) != self.nstrings.value:
        fail(&#34;strings != nstrings&#34;)
        print(len(self.strings.value), self.nstrings.value)
        return False

    if self.version.value &gt;= 5:
        if self.nbytes is None or self.bytes is None:
            fail(&#34;nbytes or bytes is None and version &gt;= 5&#34;)
            return False
        if len(self.bytes.value) != self.nbytes.value:
            fail(&#34;bytes != nbytes&#34;)
            return False

    if len(self.types) != self.ntypes.value:
        fail(&#34;types != ntypes&#34;)
        return False

    if len(self.global_types) != self.nglobals.value:
        fail(&#34;globals != nglobals&#34;)
        return False

    if len(self.natives) != self.nnatives.value:
        fail(&#34;natives != nnatives&#34;)
        return False

    if len(self.functions) != self.nfunctions.value:
        fail(&#34;functions != nfunctions&#34;)
        return False

    if self.version.value &gt;= 4:
        if self.nconstants is None:
            fail(&#34;nconstants is None and version &gt;= 4&#34;)
            return False
        if len(self.constants) != self.nconstants.value:
            fail(&#34;constants != nconstants&#34;)
            return False

    if self.has_debug_info:
        if self.ndebugfiles is None or self.debugfiles is None:
            fail(&#34;ndebugfiles or debugfiles is None and has_debug_info&#34;)
            return False
        if len(self.debugfiles.value) != self.ndebugfiles.value:
            fail(&#34;debugfiles != ndebugfiles&#34;)
            return False

    return True</code></pre>
</details>
<div class="desc"><p>Runs a set of basic sanity checks to make sure the bytecode is correct-ish.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.next_free_findex"><code class="name flex">
<span>def <span class="ident">next_free_findex</span></span>(<span>self) ‑> <a title="crashlink.core.fIndex" href="#crashlink.core.fIndex">fIndex</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_free_findex(self) -&gt; fIndex:
    &#34;&#34;&#34;
    Find the next available fIndex that is not already used by any function or native.
    &#34;&#34;&#34;
    used_indexes = set()
    for function in self.functions:
        used_indexes.add(function.findex.value)
    for native in self.natives:
        used_indexes.add(native.findex.value)

    index = 0
    while index in used_indexes:
        index += 1

    return fIndex(index)</code></pre>
</details>
<div class="desc"><p>Find the next available fIndex that is not already used by any function or native.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.repair"><code class="name flex">
<span>def <span class="ident">repair</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repair(self) -&gt; None:
    &#34;&#34;&#34;
    Alternate notation for code.set_meta() for the purpose of clarity.
    &#34;&#34;&#34;
    self.set_meta()</code></pre>
</details>
<div class="desc"><p>Alternate notation for code.set_meta() for the purpose of clarity.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.section_at"><code class="name flex">
<span>def <span class="ident">section_at</span></span>(<span>self, offset: int) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def section_at(self, offset: int) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the name of the bytecode data section at the offset.
    &#34;&#34;&#34;
    # returns the name of the section at the offset:
    # if the offset is after a section start and before the next section start, it&#39;s still in the first section
    for section_name, section_offset in list(reversed(self.section_offsets.items())):
        if offset &gt;= section_offset:
            return section_name
    return None</code></pre>
</details>
<div class="desc"><p>Returns the name of the bytecode data section at the offset.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self, auto_set_meta: bool = True) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self, auto_set_meta: bool = True) -&gt; bytes:
    &#34;&#34;&#34;
    Serialise the bytecode to a `bytes` object.
    &#34;&#34;&#34;
    start_time = datetime.now()
    dbg_print(&#34;---- Serialise ----&#34;)
    if auto_set_meta:
        dbg_print(&#34;Setting meta...&#34;)
        self.set_meta()
    res = b&#34;&#34;.join(
        [
            self.magic.serialise(),
            self.version.serialise(),
            self.flags.serialise(),
            self.nints.serialise(),
            self.nfloats.serialise(),
            self.nstrings.serialise(),
        ]
    )
    dbg_print(f&#34;VarInt block 1 at {hex(len(res))}&#34;)
    if self.version.value &gt;= 5 and self.nbytes:
        res += self.nbytes.serialise()
    res += b&#34;&#34;.join(
        [
            self.ntypes.serialise(),
            self.nglobals.serialise(),
            self.nnatives.serialise(),
            self.nfunctions.serialise(),
        ]
    )
    dbg_print(f&#34;VarInt block 2 at {hex(len(res))}&#34;)
    if self.version.value &gt;= 4 and self.nconstants:
        res += self.nconstants.serialise()
    res += self.entrypoint.serialise()
    res += b&#34;&#34;.join([i.serialise() for i in self.ints])
    res += b&#34;&#34;.join([f.serialise() for f in self.floats])
    res += self.strings.serialise()
    if self.version.value &gt;= 5 and self.bytes:
        res += self.bytes.serialise()
    if self.has_debug_info and self.ndebugfiles and self.debugfiles:
        res += b&#34;&#34;.join([self.ndebugfiles.serialise(), self.debugfiles.serialise()])
    res += b&#34;&#34;.join(
        [
            b&#34;&#34;.join([typ.serialise() for typ in self.types]),
            b&#34;&#34;.join([typ.serialise() for typ in self.global_types]),
            b&#34;&#34;.join([native.serialise() for native in self.natives]),
        ]
    )
    if USE_TQDM:
        res += b&#34;&#34;.join([func.serialise() for func in tqdm(self.functions)])
    else:
        res += b&#34;&#34;.join([func.serialise() for func in self.functions])
    res += b&#34;&#34;.join([constant.serialise() for constant in self.constants])
    dbg_print(f&#34;Final size: {hex(len(res))}&#34;)
    dbg_print(f&#34;{(datetime.now() - start_time).total_seconds()}s elapsed.&#34;)
    return res</code></pre>
</details>
<div class="desc"><p>Serialise the bytecode to a <code>bytes</code> object.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.set_meta"><code class="name flex">
<span>def <span class="ident">set_meta</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_meta(self) -&gt; None:
    &#34;&#34;&#34;
    Sets bytecode metadata automatically.
    &#34;&#34;&#34;
    self.flags.value = 1 if self.has_debug_info else 0
    self.nints.value = len(self.ints)
    self.nfloats.value = len(self.floats)
    self.nstrings.value = len(self.strings.value)
    if self.version.value &gt;= 5 and self.bytes and self.nbytes:
        self.nbytes.value = len(self.bytes.value)
    self.ntypes.value = len(self.types)
    self.nglobals.value = len(self.global_types)
    self.nnatives.value = len(self.natives)
    self.nfunctions.value = len(self.functions)
    if self.version.value &gt;= 4 and self.nconstants:
        self.nconstants.value = len(self.constants)
    if self.has_debug_info and self.ndebugfiles and self.debugfiles:
        self.ndebugfiles.value = len(self.debugfiles.value)</code></pre>
</details>
<div class="desc"><p>Sets bytecode metadata automatically.</p></div>
</dd>
<dt id="crashlink.core.Bytecode.t"><code class="name flex">
<span>def <span class="ident">t</span></span>(<span>self, tindex: int) ‑> <a title="crashlink.core.Type" href="#crashlink.core.Type">Type</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def t(self, tindex: int) -&gt; Type:
    &#34;&#34;&#34;
    Shorthand to get a Type by its index. Equivalent to code.types[tindex]
    &#34;&#34;&#34;
    return self.types[tindex]</code></pre>
</details>
<div class="desc"><p>Shorthand to get a Type by its index. Equivalent to code.types[tindex]</p></div>
</dd>
<dt id="crashlink.core.Bytecode.track_section"><code class="name flex">
<span>def <span class="ident">track_section</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO, section_name: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def track_section(self, f: BinaryIO | BytesIO, section_name: str) -&gt; None:
    &#34;&#34;&#34;
    Internal helper function to denote the location of a data section at a given offset.
    &#34;&#34;&#34;
    self.section_offsets[section_name] = f.tell()</code></pre>
</details>
<div class="desc"><p>Internal helper function to denote the location of a data section at a given offset.</p></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Bytes"><code class="flex name class">
<span>class <span class="ident">Bytes</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bytes(_NoDataType):
    &#34;&#34;&#34;
    Bytes type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Bytes type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.BytesBlock"><code class="flex name class">
<span>class <span class="ident">BytesBlock</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BytesBlock(Serialisable):
    &#34;&#34;&#34;
    Block of bytes in the bytecode. Contains a list of byte strings and their lengths.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.size = SerialisableInt()
        self.size.length = 4
        self.value: List[bytes] = []
        self.nbytes = 0

    def deserialise(self, f: BinaryIO | BytesIO, nbytes: int) -&gt; &#34;BytesBlock&#34;:
        self.nbytes = nbytes
        self.size.deserialise(f, length=4)
        raw = f.read(self.size.value)
        positions: List[VarInt] = []
        for _ in range(nbytes):
            pos = VarInt()
            pos.deserialise(f)
            positions.append(pos)
        positions_int = [pos.value for pos in positions]
        for i in range(len(positions_int)):
            start = positions_int[i]
            end = positions_int[i + 1] if i + 1 &lt; len(positions_int) else len(raw)
            self.value.append(raw[start:end])  # Append the extracted byte string
        return self

    def serialise(self) -&gt; bytes:
        raw_data = b&#34;&#34;.join(self.value)
        self.size.value = len(raw_data)
        size_serialised = self.size.serialise()
        positions = []
        current_pos = 0
        for byte_str in self.value:
            positions.append(VarInt(current_pos))
            current_pos += len(byte_str)
        positions_serialised = b&#34;&#34;.join([pos.serialise() for pos in positions])
        return size_serialised + raw_data + positions_serialised</code></pre>
</details>
<div class="desc"><p>Block of bytes in the bytecode. Contains a list of byte strings and their lengths.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.BytesBlock.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO, nbytes: int) ‑> <a title="crashlink.core.BytesBlock" href="#crashlink.core.BytesBlock">BytesBlock</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO, nbytes: int) -&gt; &#34;BytesBlock&#34;:
    self.nbytes = nbytes
    self.size.deserialise(f, length=4)
    raw = f.read(self.size.value)
    positions: List[VarInt] = []
    for _ in range(nbytes):
        pos = VarInt()
        pos.deserialise(f)
        positions.append(pos)
    positions_int = [pos.value for pos in positions]
    for i in range(len(positions_int)):
        start = positions_int[i]
        end = positions_int[i + 1] if i + 1 &lt; len(positions_int) else len(raw)
        self.value.append(raw[start:end])  # Append the extracted byte string
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.BytesBlock.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    raw_data = b&#34;&#34;.join(self.value)
    self.size.value = len(raw_data)
    size_serialised = self.size.serialise()
    positions = []
    current_pos = 0
    for byte_str in self.value:
        positions.append(VarInt(current_pos))
        current_pos += len(byte_str)
    positions_serialised = b&#34;&#34;.join([pos.serialise() for pos in positions])
    return size_serialised + raw_data + positions_serialised</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Constant"><code class="flex name class">
<span>class <span class="ident">Constant</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Constant(Serialisable):
    &#34;&#34;&#34;
    Represents a bytecode constant.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self._global = gIndex()
        self.nfields = VarInt()
        self.fields: List[VarInt] = []

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Constant&#34;:
        self._global.deserialise(f)
        self.nfields.deserialise(f)
        for _ in range(self.nfields.value):
            self.fields.append(VarInt().deserialise(f))
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join(
            [
                self._global.serialise(),
                self.nfields.serialise(),
                b&#34;&#34;.join([field.serialise() for field in self.fields]),
            ]
        )</code></pre>
</details>
<div class="desc"><p>Represents a bytecode constant.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Constant.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Constant" href="#crashlink.core.Constant">Constant</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Constant&#34;:
    self._global.deserialise(f)
    self.nfields.deserialise(f)
    for _ in range(self.nfields.value):
        self.fields.append(VarInt().deserialise(f))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Constant.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join(
        [
            self._global.serialise(),
            self.nfields.serialise(),
            b&#34;&#34;.join([field.serialise() for field in self.fields]),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.DebugInfo"><code class="flex name class">
<span>class <span class="ident">DebugInfo</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DebugInfo(Serialisable):
    &#34;&#34;&#34;
    Represents debug information for a function, encoded with a delta encoding scheme for compression.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.value: List[fileRef] = []

    def deserialise(self, f: BinaryIO | BytesIO, nops: int) -&gt; &#34;DebugInfo&#34;:
        tmp = []
        currfile: int = -1
        currline: int = 0
        i = 0
        while i &lt; nops:
            c = ctypes.c_uint8(ord(f.read(1))).value
            if c &amp; 1 != 0:
                c &gt;&gt;= 1
                currfile = (c &lt;&lt; 8) | ctypes.c_uint8(ord(f.read(1))).value
            elif c &amp; 2 != 0:
                delta = c &gt;&gt; 6
                count = (c &gt;&gt; 2) &amp; 15
                while count &gt; 0:
                    count -= 1
                    tmp.append(fileRef(currfile, currline))
                    i += 1
                currline += delta
            elif c &amp; 4 != 0:
                currline += c &gt;&gt; 3
                tmp.append(fileRef(currfile, currline))
                i += 1
            else:
                b2 = ctypes.c_uint8(ord(f.read(1))).value
                b3 = ctypes.c_uint8(ord(f.read(1))).value
                currline = (c &gt;&gt; 3) | (b2 &lt;&lt; 5) | (b3 &lt;&lt; 13)
                tmp.append(fileRef(currfile, currline))
                i += 1
        self.value = tmp
        return self

    def _flush_repeat(self, w: BinaryIO | BytesIO, curpos: ctypes.c_size_t, rcount: ctypes.c_size_t, pos: int) -&gt; None:
        if rcount.value &gt; 0:
            if rcount.value &gt; 15:
                w.write(ctypes.c_uint8((15 &lt;&lt; 2) | 2).value.to_bytes(1, &#34;little&#34;))
                rcount.value -= 15
                self._flush_repeat(w, curpos, rcount, pos)
            else:
                delta = pos - curpos.value
                delta = delta if 0 &lt; delta &lt; 4 else 0
                w.write(ctypes.c_uint8(((delta &lt;&lt; 6) | (rcount.value &lt;&lt; 2) | 2)).value.to_bytes(1, &#34;little&#34;))
                rcount.value = 0
                curpos.value += delta

    def serialise(self) -&gt; bytes:
        w = BytesIO()
        curfile = -1
        curpos = ctypes.c_size_t(0)
        rcount = ctypes.c_size_t(0)

        for ref in self.value:
            f = ref.value
            p = ref.line
            if f != curfile:
                self._flush_repeat(w, curpos, rcount, p)
                curfile = f
                w.write(ctypes.c_uint8(((f &gt;&gt; 7) | 1)).value.to_bytes(1, &#34;little&#34;))
                w.write(ctypes.c_uint8(f &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))

            if p != curpos.value:
                self._flush_repeat(w, curpos, rcount, p)

            if p == curpos.value:
                rcount.value += 1
            else:
                delta = p - curpos.value
                if 0 &lt; delta &lt; 32:
                    w.write(ctypes.c_uint8((delta &lt;&lt; 3) | 4).value.to_bytes(1, &#34;little&#34;))
                else:
                    w.write(ctypes.c_uint8((p &lt;&lt; 3) &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))
                    w.write(ctypes.c_uint8((p &gt;&gt; 5) &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))
                    w.write(ctypes.c_uint8((p &gt;&gt; 13) &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))
                curpos.value = p

        self._flush_repeat(w, curpos, rcount, curpos.value)

        return w.getvalue()

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, DebugInfo):
            return NotImplemented
        return self.value == other.value</code></pre>
</details>
<div class="desc"><p>Represents debug information for a function, encoded with a delta encoding scheme for compression.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.DebugInfo.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO, nops: int) ‑> <a title="crashlink.core.DebugInfo" href="#crashlink.core.DebugInfo">DebugInfo</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO, nops: int) -&gt; &#34;DebugInfo&#34;:
    tmp = []
    currfile: int = -1
    currline: int = 0
    i = 0
    while i &lt; nops:
        c = ctypes.c_uint8(ord(f.read(1))).value
        if c &amp; 1 != 0:
            c &gt;&gt;= 1
            currfile = (c &lt;&lt; 8) | ctypes.c_uint8(ord(f.read(1))).value
        elif c &amp; 2 != 0:
            delta = c &gt;&gt; 6
            count = (c &gt;&gt; 2) &amp; 15
            while count &gt; 0:
                count -= 1
                tmp.append(fileRef(currfile, currline))
                i += 1
            currline += delta
        elif c &amp; 4 != 0:
            currline += c &gt;&gt; 3
            tmp.append(fileRef(currfile, currline))
            i += 1
        else:
            b2 = ctypes.c_uint8(ord(f.read(1))).value
            b3 = ctypes.c_uint8(ord(f.read(1))).value
            currline = (c &gt;&gt; 3) | (b2 &lt;&lt; 5) | (b3 &lt;&lt; 13)
            tmp.append(fileRef(currfile, currline))
            i += 1
    self.value = tmp
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.DebugInfo.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    w = BytesIO()
    curfile = -1
    curpos = ctypes.c_size_t(0)
    rcount = ctypes.c_size_t(0)

    for ref in self.value:
        f = ref.value
        p = ref.line
        if f != curfile:
            self._flush_repeat(w, curpos, rcount, p)
            curfile = f
            w.write(ctypes.c_uint8(((f &gt;&gt; 7) | 1)).value.to_bytes(1, &#34;little&#34;))
            w.write(ctypes.c_uint8(f &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))

        if p != curpos.value:
            self._flush_repeat(w, curpos, rcount, p)

        if p == curpos.value:
            rcount.value += 1
        else:
            delta = p - curpos.value
            if 0 &lt; delta &lt; 32:
                w.write(ctypes.c_uint8((delta &lt;&lt; 3) | 4).value.to_bytes(1, &#34;little&#34;))
            else:
                w.write(ctypes.c_uint8((p &lt;&lt; 3) &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))
                w.write(ctypes.c_uint8((p &gt;&gt; 5) &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))
                w.write(ctypes.c_uint8((p &gt;&gt; 13) &amp; 0xFF).value.to_bytes(1, &#34;little&#34;))
            curpos.value = p

    self._flush_repeat(w, curpos, rcount, curpos.value)

    return w.getvalue()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Dyn"><code class="flex name class">
<span>class <span class="ident">Dyn</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dyn(_NoDataType):
    &#34;&#34;&#34;
    Dynamic type, no data. Can store any type of data in a typed register as a pointer.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Dynamic type, no data. Can store any type of data in a typed register as a pointer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.DynObj"><code class="flex name class">
<span>class <span class="ident">DynObj</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynObj(_NoDataType):
    &#34;&#34;&#34;
    Dynamic object type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Dynamic object type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.Enum"><code class="flex name class">
<span>class <span class="ident">Enum</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Enum(TypeDef):
    &#34;&#34;&#34;
    Enum type.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.name = strRef()
        self._global = gIndex()
        self.nconstructs = VarInt()
        self.constructs: List[EnumConstruct] = []

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Enum&#34;:
        self.name.deserialise(f)
        self._global.deserialise(f)
        self.nconstructs.deserialise(f)
        for _ in range(self.nconstructs.value):
            self.constructs.append(EnumConstruct().deserialise(f))
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join(
            [
                self.name.serialise(),
                self._global.serialise(),
                self.nconstructs.serialise(),
                b&#34;&#34;.join([construct.serialise() for construct in self.constructs]),
            ]
        )</code></pre>
</details>
<div class="desc"><p>Enum type.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Enum.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Enum" href="#crashlink.core.Enum">Enum</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Enum&#34;:
    self.name.deserialise(f)
    self._global.deserialise(f)
    self.nconstructs.deserialise(f)
    for _ in range(self.nconstructs.value):
        self.constructs.append(EnumConstruct().deserialise(f))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Enum.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join(
        [
            self.name.serialise(),
            self._global.serialise(),
            self.nconstructs.serialise(),
            b&#34;&#34;.join([construct.serialise() for construct in self.constructs]),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.EnumConstruct"><code class="flex name class">
<span>class <span class="ident">EnumConstruct</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumConstruct(Serialisable):
    &#34;&#34;&#34;
    Construct of an enum.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.name = strRef()
        self.nparams = VarInt()
        self.params: List[tIndex] = []

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;EnumConstruct&#34;:
        self.name.deserialise(f)
        self.nparams.deserialise(f)
        for _ in range(self.nparams.value):
            self.params.append(tIndex().deserialise(f))
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join(
            [
                self.name.serialise(),
                self.nparams.serialise(),
                b&#34;&#34;.join([param.serialise() for param in self.params]),
            ]
        )</code></pre>
</details>
<div class="desc"><p>Construct of an enum.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.EnumConstruct.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.EnumConstruct" href="#crashlink.core.EnumConstruct">EnumConstruct</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;EnumConstruct&#34;:
    self.name.deserialise(f)
    self.nparams.deserialise(f)
    for _ in range(self.nparams.value):
        self.params.append(tIndex().deserialise(f))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.EnumConstruct.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join(
        [
            self.name.serialise(),
            self.nparams.serialise(),
            b&#34;&#34;.join([param.serialise() for param in self.params]),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.F32"><code class="flex name class">
<span>class <span class="ident">F32</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class F32(_NoDataType):
    &#34;&#34;&#34;
    32-bit float type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>32-bit float type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.F64"><code class="flex name class">
<span>class <span class="ident">F64</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class F64(_NoDataType):
    &#34;&#34;&#34;
    64-bit float type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>64-bit float type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>name: <a title="crashlink.core.strRef" href="#crashlink.core.strRef">strRef</a> | None = None,<br>type: <a title="crashlink.core.tIndex" href="#crashlink.core.tIndex">tIndex</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field(Serialisable):
    &#34;&#34;&#34;
    Represents a field in a class definition.
    &#34;&#34;&#34;

    def __init__(self, name: Optional[strRef] = None, type: Optional[tIndex] = None) -&gt; None:
        if not name:
            self.name = strRef()
        else:
            self.name = name
        if not type:
            self.type = tIndex()
        else:
            self.type = type

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Field&#34;:
        self.name.deserialise(f)
        self.type.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join([self.name.serialise(), self.type.serialise()])</code></pre>
</details>
<div class="desc"><p>Represents a field in a class definition.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Field.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Field" href="#crashlink.core.Field">Field</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Field&#34;:
    self.name.deserialise(f)
    self.type.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Field.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join([self.name.serialise(), self.type.serialise()])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Fun"><code class="flex name class">
<span>class <span class="ident">Fun</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fun(TypeDef):
    &#34;&#34;&#34;
    Stores metadata about a function (signatures). When referenced in conjunction with a Proto or Method, it can be used to reconstruct the full function signature. See `crashlink.disasm.func_header` for a working reference.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.nargs = VarInt()
        self.args: List[tIndex] = []
        self.ret = tIndex()

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Fun&#34;:
        self.nargs.deserialise(f)
        for _ in range(self.nargs.value):
            self.args.append(tIndex().deserialise(f))
        self.ret.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        self.nargs.value = len(self.args)
        return b&#34;&#34;.join(
            [
                self.nargs.serialise(),
                b&#34;&#34;.join([idx.serialise() for idx in self.args]),
                self.ret.serialise(),
            ]
        )</code></pre>
</details>
<div class="desc"><p>Stores metadata about a function (signatures). When referenced in conjunction with a Proto or Method, it can be used to reconstruct the full function signature. See <code><a title="crashlink.disasm.func_header" href="disasm.html#crashlink.disasm.func_header">func_header()</a></code> for a working reference.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="crashlink.core.Method" href="#crashlink.core.Method">Method</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Fun.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Fun" href="#crashlink.core.Fun">Fun</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Fun&#34;:
    self.nargs.deserialise(f)
    for _ in range(self.nargs.value):
        self.args.append(tIndex().deserialise(f))
    self.ret.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Fun.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    self.nargs.value = len(self.args)
    return b&#34;&#34;.join(
        [
            self.nargs.serialise(),
            b&#34;&#34;.join([idx.serialise() for idx in self.args]),
            self.ret.serialise(),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Function(Serialisable):
    &#34;&#34;&#34;
    Represents a function in the bytecode. Due to the interesting ways in which HashLink works, this does not have a name or a signature, but rather a return type and a list of registers and opcodes.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.type = tIndex()
        self.findex = fIndex()
        self.nregs = VarInt()
        self.nops = VarInt()
        self.regs: List[tIndex] = []
        self.ops: List[Opcode] = []
        self.has_debug: Optional[bool] = None
        self.version: Optional[int] = None
        self.debuginfo: Optional[DebugInfo] = None
        self.nassigns: Optional[VarInt] = None
        self.assigns: Optional[List[Tuple[strRef, VarInt]]] = None

    def resolve_file(self, code: &#34;Bytecode&#34;) -&gt; str:
        &#34;&#34;&#34;
        Resolves (in the Bytecode&#39;s debugfiles blob) the name of the file this function originates from. Note that this assumes the first opcode&#39;s file is the only file this Function was derived from - Functions that derive from multiple files (such as compiler-generated closures or entrypoints) will be resolved to a single file, sometimes incorrectly.
        &#34;&#34;&#34;
        if not self.has_debug or not self.debuginfo:
            raise ValueError(&#34;Cannot get file from non-debug bytecode!&#34;)
        return self.debuginfo.value[0].resolve(code)

    def deserialise(self, f: BinaryIO | BytesIO, has_debug: bool, version: int) -&gt; &#34;Function&#34;:
        self.has_debug = has_debug
        self.version = version
        self.type.deserialise(f)
        self.findex.deserialise(f)
        self.nregs.deserialise(f)
        self.nops.deserialise(f)
        for _ in range(self.nregs.value):
            self.regs.append(tIndex().deserialise(f))
        for _ in range(self.nops.value):
            self.ops.append(Opcode().deserialise(f))
        if self.has_debug:
            self.debuginfo = DebugInfo().deserialise(f, self.nops.value)
            if self.version &gt;= 3:
                self.nassigns = VarInt().deserialise(f)
                self.assigns = []
                for _ in range(self.nassigns.value):
                    self.assigns.append((strRef().deserialise(f), VarInt().deserialise(f)))
        return self

    def insert_op(self, code: &#34;Bytecode&#34;, idx: int, op: Opcode, debugRef: Optional[fileRef] = None) -&gt; None:
        &#34;&#34;&#34;
        Insert an Opcode into this function at the given position, adding a blank debug fileRef if none is passed.
        &#34;&#34;&#34;
        self.ops.insert(idx, op)
        if code.debugfiles and code.has_debug_info and self.has_debug and self.debuginfo:  # fucking typing...
            if not debugRef:
                debugRef = fileRef(fid=code.debugfiles.find_or_add(&#34;?&#34;), line=42)  # life, the universe, and everything
            self.debuginfo.value.insert(idx, debugRef)

    def serialise(self) -&gt; bytes:
        self.nops.value = len(self.ops)
        self.nregs.value = len(self.regs)
        if self.assigns:
            self.nassigns = VarInt(len(self.assigns) if self.assigns else 0)
        if self.has_debug and self.debuginfo:
            assert (
                len(self.debuginfo.value) == self.nops.value
            ), f&#34;Invalid number of debugrefs - {len(self.debuginfo.value)} (debuginfo) != {self.nops.value} (nops) - did you use insert_op?&#34;
        res = b&#34;&#34;.join(
            [
                self.type.serialise(),
                self.findex.serialise(),
                self.nregs.serialise(),
                self.nops.serialise(),
                b&#34;&#34;.join([reg.serialise() for reg in self.regs]),
                b&#34;&#34;.join([op.serialise() for op in self.ops]),
            ]
        )
        if self.has_debug and self.debuginfo:
            res += self.debuginfo.serialise()
            if self.version and self.version &gt;= 3 and self.nassigns and self.assigns is not None:
                res += self.nassigns.serialise()
                res += b&#34;&#34;.join([b&#34;&#34;.join([v.serialise() for v in assign]) for assign in self.assigns])
        return res</code></pre>
</details>
<div class="desc"><p>Represents a function in the bytecode. Due to the interesting ways in which HashLink works, this does not have a name or a signature, but rather a return type and a list of registers and opcodes.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Function.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO, has_debug: bool, version: int) ‑> <a title="crashlink.core.Function" href="#crashlink.core.Function">Function</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO, has_debug: bool, version: int) -&gt; &#34;Function&#34;:
    self.has_debug = has_debug
    self.version = version
    self.type.deserialise(f)
    self.findex.deserialise(f)
    self.nregs.deserialise(f)
    self.nops.deserialise(f)
    for _ in range(self.nregs.value):
        self.regs.append(tIndex().deserialise(f))
    for _ in range(self.nops.value):
        self.ops.append(Opcode().deserialise(f))
    if self.has_debug:
        self.debuginfo = DebugInfo().deserialise(f, self.nops.value)
        if self.version &gt;= 3:
            self.nassigns = VarInt().deserialise(f)
            self.assigns = []
            for _ in range(self.nassigns.value):
                self.assigns.append((strRef().deserialise(f), VarInt().deserialise(f)))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Function.insert_op"><code class="name flex">
<span>def <span class="ident">insert_op</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>,<br>idx: int,<br>op: <a title="crashlink.core.Opcode" href="#crashlink.core.Opcode">Opcode</a>,<br>debugRef: <a title="crashlink.core.fileRef" href="#crashlink.core.fileRef">fileRef</a> | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_op(self, code: &#34;Bytecode&#34;, idx: int, op: Opcode, debugRef: Optional[fileRef] = None) -&gt; None:
    &#34;&#34;&#34;
    Insert an Opcode into this function at the given position, adding a blank debug fileRef if none is passed.
    &#34;&#34;&#34;
    self.ops.insert(idx, op)
    if code.debugfiles and code.has_debug_info and self.has_debug and self.debuginfo:  # fucking typing...
        if not debugRef:
            debugRef = fileRef(fid=code.debugfiles.find_or_add(&#34;?&#34;), line=42)  # life, the universe, and everything
        self.debuginfo.value.insert(idx, debugRef)</code></pre>
</details>
<div class="desc"><p>Insert an Opcode into this function at the given position, adding a blank debug fileRef if none is passed.</p></div>
</dd>
<dt id="crashlink.core.Function.resolve_file"><code class="name flex">
<span>def <span class="ident">resolve_file</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_file(self, code: &#34;Bytecode&#34;) -&gt; str:
    &#34;&#34;&#34;
    Resolves (in the Bytecode&#39;s debugfiles blob) the name of the file this function originates from. Note that this assumes the first opcode&#39;s file is the only file this Function was derived from - Functions that derive from multiple files (such as compiler-generated closures or entrypoints) will be resolved to a single file, sometimes incorrectly.
    &#34;&#34;&#34;
    if not self.has_debug or not self.debuginfo:
        raise ValueError(&#34;Cannot get file from non-debug bytecode!&#34;)
    return self.debuginfo.value[0].resolve(code)</code></pre>
</details>
<div class="desc"><p>Resolves (in the Bytecode's debugfiles blob) the name of the file this function originates from. Note that this assumes the first opcode's file is the only file this Function was derived from - Functions that derive from multiple files (such as compiler-generated closures or entrypoints) will be resolved to a single file, sometimes incorrectly.</p></div>
</dd>
<dt id="crashlink.core.Function.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    self.nops.value = len(self.ops)
    self.nregs.value = len(self.regs)
    if self.assigns:
        self.nassigns = VarInt(len(self.assigns) if self.assigns else 0)
    if self.has_debug and self.debuginfo:
        assert (
            len(self.debuginfo.value) == self.nops.value
        ), f&#34;Invalid number of debugrefs - {len(self.debuginfo.value)} (debuginfo) != {self.nops.value} (nops) - did you use insert_op?&#34;
    res = b&#34;&#34;.join(
        [
            self.type.serialise(),
            self.findex.serialise(),
            self.nregs.serialise(),
            self.nops.serialise(),
            b&#34;&#34;.join([reg.serialise() for reg in self.regs]),
            b&#34;&#34;.join([op.serialise() for op in self.ops]),
        ]
    )
    if self.has_debug and self.debuginfo:
        res += self.debuginfo.serialise()
        if self.version and self.version &gt;= 3 and self.nassigns and self.assigns is not None:
            res += self.nassigns.serialise()
            res += b&#34;&#34;.join([b&#34;&#34;.join([v.serialise() for v in assign]) for assign in self.assigns])
    return res</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.I32"><code class="flex name class">
<span>class <span class="ident">I32</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class I32(_NoDataType):
    &#34;&#34;&#34;
    Signed 32-bit integer type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Signed 32-bit integer type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.I64"><code class="flex name class">
<span>class <span class="ident">I64</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class I64(_NoDataType):
    &#34;&#34;&#34;
    Signed 64-bit integer type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Signed 64-bit integer type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.InlineBool"><code class="flex name class">
<span>class <span class="ident">InlineBool</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InlineBool(Serialisable):
    &#34;&#34;&#34;
    Inline boolean value.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.varint = VarInt()
        self.value: bool = False

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;InlineBool&#34;:
        self.varint.deserialise(f)
        self.value = bool(self.varint.value)
        return self

    def serialise(self) -&gt; bytes:
        self.varint.value = int(self.value)
        return self.varint.serialise()</code></pre>
</details>
<div class="desc"><p>Inline boolean value.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.InlineBool.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.InlineBool" href="#crashlink.core.InlineBool">InlineBool</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;InlineBool&#34;:
    self.varint.deserialise(f)
    self.value = bool(self.varint.value)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.InlineBool.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    self.varint.value = int(self.value)
    return self.varint.serialise()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Method"><code class="flex name class">
<span>class <span class="ident">Method</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Method(Fun):
    &#34;&#34;&#34;
    Method type, identical to Fun.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Method type, identical to Fun.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Fun" href="#crashlink.core.Fun">Fun</a></li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.Native"><code class="flex name class">
<span>class <span class="ident">Native</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Native(Serialisable):
    &#34;&#34;&#34;
    Represents a native function.

    - lib: strRef
    - name: strRef
    - type: tIndex
    - findex: fIndex
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.lib = strRef()
        self.name = strRef()
        self.type = tIndex()
        self.findex = fIndex()

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Native&#34;:
        self.lib.deserialise(f)
        self.name.deserialise(f)
        self.type.deserialise(f)
        self.findex.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join(
            [
                self.lib.serialise(),
                self.name.serialise(),
                self.type.serialise(),
                self.findex.serialise(),
            ]
        )</code></pre>
</details>
<div class="desc"><p>Represents a native function.</p>
<ul>
<li>lib: strRef</li>
<li>name: strRef</li>
<li>type: tIndex</li>
<li>findex: fIndex</li>
</ul></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Native.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Native" href="#crashlink.core.Native">Native</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Native&#34;:
    self.lib.deserialise(f)
    self.name.deserialise(f)
    self.type.deserialise(f)
    self.findex.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Native.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join(
        [
            self.lib.serialise(),
            self.name.serialise(),
            self.type.serialise(),
            self.findex.serialise(),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Null"><code class="flex name class">
<span>class <span class="ident">Null</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Null(TypeDef):
    &#34;&#34;&#34;
    Null of a certain type.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.type = tIndex()

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Null&#34;:
        self.type.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return self.type.serialise()</code></pre>
</details>
<div class="desc"><p>Null of a certain type.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Null.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Null" href="#crashlink.core.Null">Null</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Null&#34;:
    self.type.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Null.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return self.type.serialise()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Obj"><code class="flex name class">
<span>class <span class="ident">Obj</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Obj(TypeDef):
    &#34;&#34;&#34;
    Represents a class definition. Contains:

    - name: strRef
    - super: tIndex
    - _global: gIndex
    - nfields: VarInt
    - nprotos: VarInt
    - nbindings: VarInt
    - fields: List[Field]
    - protos: List[Proto]
    - bindings: List[Binding]
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.name = strRef()
        self.super = tIndex()
        self._global = gIndex()
        self.nfields = VarInt()
        self.nprotos = VarInt()
        self.nbindings = VarInt()
        self.fields: List[Field] = []
        self.protos: List[Proto] = []
        self.bindings: List[Binding] = []

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Obj&#34;:
        self.name.deserialise(f)
        self.super.deserialise(f)
        self._global.deserialise(f)
        self.nfields.deserialise(f)
        self.nprotos.deserialise(f)
        self.nbindings.deserialise(f)
        for _ in range(self.nfields.value):
            self.fields.append(Field().deserialise(f))
        for _ in range(self.nprotos.value):
            self.protos.append(Proto().deserialise(f))
        for _ in range(self.nbindings.value):
            self.bindings.append(Binding().deserialise(f))
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join(
            [
                self.name.serialise(),
                self.super.serialise(),
                self._global.serialise(),
                self.nfields.serialise(),
                self.nprotos.serialise(),
                self.nbindings.serialise(),
                b&#34;&#34;.join([field.serialise() for field in self.fields]),
                b&#34;&#34;.join([proto.serialise() for proto in self.protos]),
                b&#34;&#34;.join([binding.serialise() for binding in self.bindings]),
            ]
        )

    def resolve_fields(self, code: &#34;Bytecode&#34;) -&gt; List[Field]:
        &#34;&#34;&#34;
        Resolves all fields across the class heirarchy. For instance:
        class A {
            var a: Int;
        }
        class B extends A {
            var b: Int;
        }
        Where a is field 0 and b is field 1
        &#34;&#34;&#34;
        if self.super.value &lt; 0:  # no superclass
            return self.fields
        fields: List[Field] = []
        visited_types = set()
        current_type: Optional[Obj] = self
        while current_type:
            if id(current_type) in visited_types:
                raise ValueError(&#34;Cyclic inheritance detected in class hierarchy.&#34;)
            visited_types.add(id(current_type))
            fields = current_type.fields + fields
            if current_type.super.value &lt; 0:
                current_type = None
            else:
                defn = current_type.super.resolve(code).definition
                if not isinstance(defn, Obj):
                    raise ValueError(&#34;Invalid superclass type.&#34;)
                current_type = defn
        return fields

    def __str__(self) -&gt; str:
        return f&#34;&lt;Obj: f@{self.name}&gt;&#34;

    def __repr__(self) -&gt; str:
        return self.__str__()

    def str_resolve(self, code: &#34;Bytecode&#34;) -&gt; str:
        return f&#34;&lt;Obj: {self.name.resolve(code)}&gt;&#34;</code></pre>
</details>
<div class="desc"><p>Represents a class definition. Contains:</p>
<ul>
<li>name: strRef</li>
<li>super: tIndex</li>
<li>_global: gIndex</li>
<li>nfields: VarInt</li>
<li>nprotos: VarInt</li>
<li>nbindings: VarInt</li>
<li>fields: List[Field]</li>
<li>protos: List[Proto]</li>
<li>bindings: List[Binding]</li>
</ul></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="crashlink.core.Struct" href="#crashlink.core.Struct">Struct</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Obj.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Obj" href="#crashlink.core.Obj">Obj</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Obj&#34;:
    self.name.deserialise(f)
    self.super.deserialise(f)
    self._global.deserialise(f)
    self.nfields.deserialise(f)
    self.nprotos.deserialise(f)
    self.nbindings.deserialise(f)
    for _ in range(self.nfields.value):
        self.fields.append(Field().deserialise(f))
    for _ in range(self.nprotos.value):
        self.protos.append(Proto().deserialise(f))
    for _ in range(self.nbindings.value):
        self.bindings.append(Binding().deserialise(f))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Obj.resolve_fields"><code class="name flex">
<span>def <span class="ident">resolve_fields</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> List[<a title="crashlink.core.Field" href="#crashlink.core.Field">Field</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_fields(self, code: &#34;Bytecode&#34;) -&gt; List[Field]:
    &#34;&#34;&#34;
    Resolves all fields across the class heirarchy. For instance:
    class A {
        var a: Int;
    }
    class B extends A {
        var b: Int;
    }
    Where a is field 0 and b is field 1
    &#34;&#34;&#34;
    if self.super.value &lt; 0:  # no superclass
        return self.fields
    fields: List[Field] = []
    visited_types = set()
    current_type: Optional[Obj] = self
    while current_type:
        if id(current_type) in visited_types:
            raise ValueError(&#34;Cyclic inheritance detected in class hierarchy.&#34;)
        visited_types.add(id(current_type))
        fields = current_type.fields + fields
        if current_type.super.value &lt; 0:
            current_type = None
        else:
            defn = current_type.super.resolve(code).definition
            if not isinstance(defn, Obj):
                raise ValueError(&#34;Invalid superclass type.&#34;)
            current_type = defn
    return fields</code></pre>
</details>
<div class="desc"><p>Resolves all fields across the class heirarchy. For instance:
class A {
var a: Int;
}
class B extends A {
var b: Int;
}
Where a is field 0 and b is field 1</p></div>
</dd>
<dt id="crashlink.core.Obj.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join(
        [
            self.name.serialise(),
            self.super.serialise(),
            self._global.serialise(),
            self.nfields.serialise(),
            self.nprotos.serialise(),
            self.nbindings.serialise(),
            b&#34;&#34;.join([field.serialise() for field in self.fields]),
            b&#34;&#34;.join([proto.serialise() for proto in self.protos]),
            b&#34;&#34;.join([binding.serialise() for binding in self.bindings]),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Obj.str_resolve"><code class="name flex">
<span>def <span class="ident">str_resolve</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_resolve(self, code: &#34;Bytecode&#34;) -&gt; str:
    return f&#34;&lt;Obj: {self.name.resolve(code)}&gt;&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Opcode"><code class="flex name class">
<span>class <span class="ident">Opcode</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Opcode(Serialisable):
    &#34;&#34;&#34;
    Represents an opcode.
    &#34;&#34;&#34;

    TYPE_MAP: Dict[str, type] = {
        &#34;Reg&#34;: Reg,
        &#34;Regs&#34;: Regs,
        &#34;RefInt&#34;: intRef,
        &#34;RefFloat&#34;: floatRef,
        &#34;InlineBool&#34;: InlineBool,
        &#34;RefBytes&#34;: bytesRef,
        &#34;RefString&#34;: strRef,
        &#34;RefFun&#34;: fIndex,
        &#34;RefField&#34;: fieldRef,
        &#34;RefGlobal&#34;: gIndex,
        &#34;JumpOffset&#34;: VarInt,
        &#34;JumpOffsets&#34;: VarInts,
        &#34;RefType&#34;: tIndex,
        &#34;RefEnumConstant&#34;: VarInt,
        &#34;RefEnumConstruct&#34;: VarInt,
        &#34;InlineInt&#34;: VarInt,
    }

    def __init__(self) -&gt; None:
        self.code = VarInt()
        self.op: Optional[str] = None
        self.definition: Dict[Any, Any] = {}

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Opcode&#34;:
        # dbg_print(f&#34;Deserialising opcode at {tell(f)}... &#34;, end=&#34;&#34;)
        self.code.deserialise(f)
        # dbg_print(f&#34;{self.code.value}... &#34;, end=&#34;&#34;)
        try:
            _def = opcodes[list(opcodes.keys())[self.code.value]]
        except IndexError:
            raise InvalidOpCode(f&#34;Unknown opcode at {tell(f)} - {self.code.value}&#34;)
        for param, _type in _def.items():
            if _type in self.TYPE_MAP:
                self.definition[param] = self.TYPE_MAP[_type]().deserialise(f)
                continue
            raise InvalidOpCode(f&#34;Invalid opcode definition for {param, _type} at {tell(f)}&#34;)
        self.op = list(opcodes.keys())[self.code.value]
        return self

    def serialise(self) -&gt; bytes:
        if self.op:
            self.code.value = list(opcodes.keys()).index(self.op)
        return b&#34;&#34;.join(
            [
                self.code.serialise(),
                b&#34;&#34;.join([definition.serialise() for name, definition in self.definition.items()]),
            ]
        )

    def __repr__(self) -&gt; str:
        return f&#34;&lt;Opcode: {self.op} {self.definition}&gt;&#34;

    def __str__(self) -&gt; str:
        return self.__repr__()</code></pre>
</details>
<div class="desc"><p>Represents an opcode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="crashlink.core.Opcode.TYPE_MAP"><code class="name">var <span class="ident">TYPE_MAP</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Opcode.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Opcode" href="#crashlink.core.Opcode">Opcode</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Opcode&#34;:
    # dbg_print(f&#34;Deserialising opcode at {tell(f)}... &#34;, end=&#34;&#34;)
    self.code.deserialise(f)
    # dbg_print(f&#34;{self.code.value}... &#34;, end=&#34;&#34;)
    try:
        _def = opcodes[list(opcodes.keys())[self.code.value]]
    except IndexError:
        raise InvalidOpCode(f&#34;Unknown opcode at {tell(f)} - {self.code.value}&#34;)
    for param, _type in _def.items():
        if _type in self.TYPE_MAP:
            self.definition[param] = self.TYPE_MAP[_type]().deserialise(f)
            continue
        raise InvalidOpCode(f&#34;Invalid opcode definition for {param, _type} at {tell(f)}&#34;)
    self.op = list(opcodes.keys())[self.code.value]
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Opcode.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    if self.op:
        self.code.value = list(opcodes.keys()).index(self.op)
    return b&#34;&#34;.join(
        [
            self.code.serialise(),
            b&#34;&#34;.join([definition.serialise() for name, definition in self.definition.items()]),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Packed"><code class="flex name class">
<span>class <span class="ident">Packed</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Packed(TypeDef):
    &#34;&#34;&#34;
    Holds an inner type index.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.inner = tIndex()

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Packed&#34;:
        self.inner.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return self.inner.serialise()</code></pre>
</details>
<div class="desc"><p>Holds an inner type index.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Packed.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Packed" href="#crashlink.core.Packed">Packed</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Packed&#34;:
    self.inner.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Packed.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return self.inner.serialise()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Proto"><code class="flex name class">
<span>class <span class="ident">Proto</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Proto(Serialisable):
    &#34;&#34;&#34;
    Represents a prototype of a function
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.name = strRef()
        self.findex = fIndex()
        self.pindex = VarInt()  # unknown use

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Proto&#34;:
        self.name.deserialise(f)
        self.findex.deserialise(f)
        self.pindex.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join([self.name.serialise(), self.findex.serialise(), self.pindex.serialise()])</code></pre>
</details>
<div class="desc"><p>Represents a prototype of a function</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Proto.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Proto" href="#crashlink.core.Proto">Proto</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Proto&#34;:
    self.name.deserialise(f)
    self.findex.deserialise(f)
    self.pindex.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Proto.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join([self.name.serialise(), self.findex.serialise(), self.pindex.serialise()])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.RawData"><code class="flex name class">
<span>class <span class="ident">RawData</span></span>
<span>(</span><span>length: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawData(Serialisable):
    &#34;&#34;&#34;
    A block of raw data.
    &#34;&#34;&#34;

    def __init__(self, length: int):
        self.value: bytes = b&#34;&#34;
        self.length = length

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;RawData&#34;:
        self.value = f.read(self.length)
        return self

    def serialise(self) -&gt; bytes:
        return self.value</code></pre>
</details>
<div class="desc"><p>A block of raw data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.RawData.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.RawData" href="#crashlink.core.RawData">RawData</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;RawData&#34;:
    self.value = f.read(self.length)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.RawData.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return self.value</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Ref"><code class="flex name class">
<span>class <span class="ident">Ref</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ref(TypeDef):
    &#34;&#34;&#34;
    Memory reference to an instance of a type.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.type = tIndex()

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Ref&#34;:
        self.type.deserialise(f)
        return self

    def serialise(self) -&gt; bytes:
        return self.type.serialise()</code></pre>
</details>
<div class="desc"><p>Memory reference to an instance of a type.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Ref.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Ref" href="#crashlink.core.Ref">Ref</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Ref&#34;:
    self.type.deserialise(f)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Ref.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return self.type.serialise()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Reg"><code class="flex name class">
<span>class <span class="ident">Reg</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reg(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a register in the bytecode.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; &#34;Type&#34;:
        return code.types[self.value]</code></pre>
</details>
<div class="desc"><p>Reference to a register in the bytecode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.Regs"><code class="flex name class">
<span>class <span class="ident">Regs</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Regs(Serialisable):
    &#34;&#34;&#34;
    List of references to registers.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.n = VarInt()
        self.value: List[Reg] = []

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Regs&#34;:
        self.n.deserialise(f)
        for _ in range(self.n.value):
            self.value.append(Reg().deserialise(f))
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join([self.n.serialise(), b&#34;&#34;.join([value.serialise() for value in self.value])])</code></pre>
</details>
<div class="desc"><p>List of references to registers.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Regs.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Regs" href="#crashlink.core.Regs">Regs</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Regs&#34;:
    self.n.deserialise(f)
    for _ in range(self.n.value):
        self.value.append(Reg().deserialise(f))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Regs.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join([self.n.serialise(), b&#34;&#34;.join([value.serialise() for value in self.value])])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.ResolvableVarInt"><code class="flex name class">
<span>class <span class="ident">ResolvableVarInt</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResolvableVarInt(VarInt, ABC):
    &#34;&#34;&#34;
    Base class for resolvable VarInts. Call `resolve` to get a direct reference to the object it points to.
    &#34;&#34;&#34;

    @abstractmethod
    def resolve(self, code: &#34;Bytecode&#34;) -&gt; Any:
        &#34;&#34;&#34;
        Resolve this reference to a specific reference in the bytecode.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<div class="desc"><p>Base class for resolvable VarInts. Call <code>resolve</code> to get a direct reference to the object it points to.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="crashlink.core.Reg" href="#crashlink.core.Reg">Reg</a></li>
<li><a title="crashlink.core.bytesRef" href="#crashlink.core.bytesRef">bytesRef</a></li>
<li><a title="crashlink.core.fIndex" href="#crashlink.core.fIndex">fIndex</a></li>
<li><a title="crashlink.core.fieldRef" href="#crashlink.core.fieldRef">fieldRef</a></li>
<li><a title="crashlink.core.fileRef" href="#crashlink.core.fileRef">fileRef</a></li>
<li><a title="crashlink.core.floatRef" href="#crashlink.core.floatRef">floatRef</a></li>
<li><a title="crashlink.core.gIndex" href="#crashlink.core.gIndex">gIndex</a></li>
<li><a title="crashlink.core.intRef" href="#crashlink.core.intRef">intRef</a></li>
<li><a title="crashlink.core.strRef" href="#crashlink.core.strRef">strRef</a></li>
<li><a title="crashlink.core.tIndex" href="#crashlink.core.tIndex">tIndex</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.ResolvableVarInt.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def resolve(self, code: &#34;Bytecode&#34;) -&gt; Any:
    &#34;&#34;&#34;
    Resolve this reference to a specific reference in the bytecode.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Resolve this reference to a specific reference in the bytecode.</p></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Serialisable"><code class="flex name class">
<span>class <span class="ident">Serialisable</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Serialisable(ABC):
    &#34;&#34;&#34;
    Base class for all serialisable objects.
    &#34;&#34;&#34;

    @abstractmethod
    def __init__(self) -&gt; None:
        self.value: Any = None

    @abstractmethod
    def deserialise(self, f: BinaryIO | BytesIO, *args: Any, **kwargs: Any) -&gt; &#34;Serialisable&#34;:
        pass

    @abstractmethod
    def serialise(self) -&gt; bytes:
        pass

    def __str__(self) -&gt; str:
        try:
            return str(self.value)
        except AttributeError:
            return super().__repr__()

    def __repr__(self) -&gt; str:
        try:
            return str(self.value)
        except AttributeError:
            return super().__repr__()

    def __eq__(self, other: object) -&gt; Any:
        if not isinstance(other, Serialisable):
            return NotImplemented
        return self.value == other.value

    def __ne__(self, other: object) -&gt; Any:
        if not isinstance(other, Serialisable):
            return NotImplemented
        return self.value != other.value

    def __lt__(self, other: object) -&gt; Any:
        if not isinstance(other, Serialisable):
            return NotImplemented
        return self.value &lt; other.value</code></pre>
</details>
<div class="desc"><p>Base class for all serialisable objects.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="crashlink.core.Binding" href="#crashlink.core.Binding">Binding</a></li>
<li><a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a></li>
<li><a title="crashlink.core.BytesBlock" href="#crashlink.core.BytesBlock">BytesBlock</a></li>
<li><a title="crashlink.core.Constant" href="#crashlink.core.Constant">Constant</a></li>
<li><a title="crashlink.core.DebugInfo" href="#crashlink.core.DebugInfo">DebugInfo</a></li>
<li><a title="crashlink.core.EnumConstruct" href="#crashlink.core.EnumConstruct">EnumConstruct</a></li>
<li><a title="crashlink.core.Field" href="#crashlink.core.Field">Field</a></li>
<li><a title="crashlink.core.Function" href="#crashlink.core.Function">Function</a></li>
<li><a title="crashlink.core.InlineBool" href="#crashlink.core.InlineBool">InlineBool</a></li>
<li><a title="crashlink.core.Native" href="#crashlink.core.Native">Native</a></li>
<li><a title="crashlink.core.Opcode" href="#crashlink.core.Opcode">Opcode</a></li>
<li><a title="crashlink.core.Proto" href="#crashlink.core.Proto">Proto</a></li>
<li><a title="crashlink.core.RawData" href="#crashlink.core.RawData">RawData</a></li>
<li><a title="crashlink.core.Regs" href="#crashlink.core.Regs">Regs</a></li>
<li><a title="crashlink.core.SerialisableF64" href="#crashlink.core.SerialisableF64">SerialisableF64</a></li>
<li><a title="crashlink.core.SerialisableInt" href="#crashlink.core.SerialisableInt">SerialisableInt</a></li>
<li><a title="crashlink.core.StringsBlock" href="#crashlink.core.StringsBlock">StringsBlock</a></li>
<li><a title="crashlink.core.Type" href="#crashlink.core.Type">Type</a></li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.VarInts" href="#crashlink.core.VarInts">VarInts</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Serialisable.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO, *args: Any, **kwargs: Any) ‑> <a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def deserialise(self, f: BinaryIO | BytesIO, *args: Any, **kwargs: Any) -&gt; &#34;Serialisable&#34;:
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Serialisable.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def serialise(self) -&gt; bytes:
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.SerialisableF64"><code class="flex name class">
<span>class <span class="ident">SerialisableF64</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerialisableF64(Serialisable):
    &#34;&#34;&#34;
    A standard 64-bit float.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.value = 0.0

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;SerialisableF64&#34;:
        self.value = struct.unpack(&#34;&lt;d&#34;, f.read(8))[0]
        return self

    def serialise(self) -&gt; bytes:
        return struct.pack(&#34;&lt;d&#34;, self.value)</code></pre>
</details>
<div class="desc"><p>A standard 64-bit float.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.SerialisableF64.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.SerialisableF64" href="#crashlink.core.SerialisableF64">SerialisableF64</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;SerialisableF64&#34;:
    self.value = struct.unpack(&#34;&lt;d&#34;, f.read(8))[0]
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.SerialisableF64.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return struct.pack(&#34;&lt;d&#34;, self.value)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.SerialisableInt"><code class="flex name class">
<span>class <span class="ident">SerialisableInt</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerialisableInt(Serialisable):
    &#34;&#34;&#34;
    Integer of the specified byte length.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.value: int = -1
        self.length = 4
        self.byteorder: Literal[&#34;little&#34;, &#34;big&#34;] = &#34;little&#34;
        self.signed = False

    def deserialise(
        self,
        f: BinaryIO | BytesIO,
        length: int = 4,
        byteorder: Literal[&#34;little&#34;, &#34;big&#34;] = &#34;little&#34;,
        signed: bool = False,
    ) -&gt; &#34;SerialisableInt&#34;:
        self.length = length
        self.byteorder = byteorder
        self.signed = signed
        bytes = f.read(length)
        if all(b == 0 for b in bytes):
            self.value = 0
            return self
        while bytes[-1] == 0:
            bytes = bytes[:-1]
        self.value = int.from_bytes(bytes, byteorder, signed=signed)
        return self

    def serialise(self) -&gt; bytes:
        return self.value.to_bytes(self.length, self.byteorder, signed=self.signed)</code></pre>
</details>
<div class="desc"><p>Integer of the specified byte length.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.SerialisableInt.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self,<br>f: typing.BinaryIO | _io.BytesIO,<br>length: int = 4,<br>byteorder: Literal['little', 'big'] = 'little',<br>signed: bool = False) ‑> <a title="crashlink.core.SerialisableInt" href="#crashlink.core.SerialisableInt">SerialisableInt</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(
    self,
    f: BinaryIO | BytesIO,
    length: int = 4,
    byteorder: Literal[&#34;little&#34;, &#34;big&#34;] = &#34;little&#34;,
    signed: bool = False,
) -&gt; &#34;SerialisableInt&#34;:
    self.length = length
    self.byteorder = byteorder
    self.signed = signed
    bytes = f.read(length)
    if all(b == 0 for b in bytes):
        self.value = 0
        return self
    while bytes[-1] == 0:
        bytes = bytes[:-1]
    self.value = int.from_bytes(bytes, byteorder, signed=signed)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.SerialisableInt.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return self.value.to_bytes(self.length, self.byteorder, signed=self.signed)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.StringsBlock"><code class="flex name class">
<span>class <span class="ident">StringsBlock</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringsBlock(Serialisable):
    &#34;&#34;&#34;
    Block of strings in the bytecode. Contains a list of strings and their lengths.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.length = SerialisableInt()
        self.length.length = 4
        self.value: List[str] = []
        self.lengths: List[VarInt] = []

    def deserialise(self, f: BinaryIO | BytesIO, nstrings: int) -&gt; &#34;StringsBlock&#34;:
        self.length.deserialise(f, length=4)
        size = self.length.value
        sdata: bytes = f.read(size)
        strings: List[str] = []
        lengths: List[VarInt] = []
        curpos = 0

        for _ in range(nstrings):
            sz = VarInt().deserialise(f)
            # Check if we can read string + null terminator
            if curpos + sz.value + 1 &gt; size:
                raise ValueError(&#34;Invalid string&#34;)

            # Verify null terminator
            if sdata[curpos + sz.value] != 0:
                raise ValueError(&#34;Invalid string&#34;)

            str_value = sdata[curpos : curpos + sz.value]
            strings.append(str_value.decode(&#34;utf-8&#34;, errors=&#34;surrogateescape&#34;))
            lengths.append(sz)

            curpos += sz.value + 1  # Move past string and null terminator

        self.value = strings
        self.lengths = lengths
        return self

    def serialise(self) -&gt; bytes:
        strings_data = bytearray()
        for string in self.value:
            encoded = string.encode(&#34;utf-8&#34;, errors=&#34;surrogateescape&#34;)
            strings_data.extend(encoded)
            strings_data.append(0)  # null terminator

        self.length.value = len(strings_data)
        self.lengths = [VarInt(len(string.encode(&#34;utf-8&#34;, errors=&#34;surrogateescape&#34;))) for string in self.value]

        result = bytearray(self.length.serialise())
        result.extend(strings_data)
        for length in self.lengths:
            result.extend(length.serialise())

        return bytes(result)

    def find_or_add(self, val: str) -&gt; int:
        &#34;&#34;&#34;
        Finds and returns the index of a string value in this block, or adds it to this block and returns its index.
        &#34;&#34;&#34;
        if val in self.value:
            return self.value.index(val)
        self.value.append(val)
        return len(self.value) - 1</code></pre>
</details>
<div class="desc"><p>Block of strings in the bytecode. Contains a list of strings and their lengths.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.StringsBlock.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO, nstrings: int) ‑> <a title="crashlink.core.StringsBlock" href="#crashlink.core.StringsBlock">StringsBlock</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO, nstrings: int) -&gt; &#34;StringsBlock&#34;:
    self.length.deserialise(f, length=4)
    size = self.length.value
    sdata: bytes = f.read(size)
    strings: List[str] = []
    lengths: List[VarInt] = []
    curpos = 0

    for _ in range(nstrings):
        sz = VarInt().deserialise(f)
        # Check if we can read string + null terminator
        if curpos + sz.value + 1 &gt; size:
            raise ValueError(&#34;Invalid string&#34;)

        # Verify null terminator
        if sdata[curpos + sz.value] != 0:
            raise ValueError(&#34;Invalid string&#34;)

        str_value = sdata[curpos : curpos + sz.value]
        strings.append(str_value.decode(&#34;utf-8&#34;, errors=&#34;surrogateescape&#34;))
        lengths.append(sz)

        curpos += sz.value + 1  # Move past string and null terminator

    self.value = strings
    self.lengths = lengths
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.StringsBlock.find_or_add"><code class="name flex">
<span>def <span class="ident">find_or_add</span></span>(<span>self, val: str) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_or_add(self, val: str) -&gt; int:
    &#34;&#34;&#34;
    Finds and returns the index of a string value in this block, or adds it to this block and returns its index.
    &#34;&#34;&#34;
    if val in self.value:
        return self.value.index(val)
    self.value.append(val)
    return len(self.value) - 1</code></pre>
</details>
<div class="desc"><p>Finds and returns the index of a string value in this block, or adds it to this block and returns its index.</p></div>
</dd>
<dt id="crashlink.core.StringsBlock.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    strings_data = bytearray()
    for string in self.value:
        encoded = string.encode(&#34;utf-8&#34;, errors=&#34;surrogateescape&#34;)
        strings_data.extend(encoded)
        strings_data.append(0)  # null terminator

    self.length.value = len(strings_data)
    self.lengths = [VarInt(len(string.encode(&#34;utf-8&#34;, errors=&#34;surrogateescape&#34;))) for string in self.value]

    result = bytearray(self.length.serialise())
    result.extend(strings_data)
    for length in self.lengths:
        result.extend(length.serialise())

    return bytes(result)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Struct(Obj):
    &#34;&#34;&#34;
    Struct type, identical to Obj.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Struct type, identical to Obj.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Obj" href="#crashlink.core.Obj">Obj</a></li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.Obj" href="#crashlink.core.Obj">Obj</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.Obj.resolve_fields" href="#crashlink.core.Obj.resolve_fields">resolve_fields</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.Type"><code class="flex name class">
<span>class <span class="ident">Type</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Type(Serialisable):
    &#34;&#34;&#34;
    Type definition:

    - kind: SerialisableInt
    - definition: TypeDef
    &#34;&#34;&#34;

    # fmt: off
    TYPEDEFS: List[type] = [
        Void,     # 0, no data
        U8,       # 1, no data
        U16,      # 2, no data
        I32,      # 3, no data
        I64,      # 4, no data
        F32,      # 5, no data
        F64,      # 6, no data
        Bool,     # 7, no data
        Bytes,    # 8, no data
        Dyn,      # 9, no data
        Fun,      # 10
        Obj,      # 11
        Array,    # 12, no data
        TypeType, # 13, no data
        Ref,      # 14
        Virtual,  # 15
        DynObj,   # 16, no data
        Abstract, # 17
        Enum,     # 18
        Null,     # 19
        Method,   # 20
        Struct,   # 21
        Packed,   # 22
    ]
    # fmt: on

    class Kind(_Enum):
        VOID = 0
        U8 = 1
        U16 = 2
        I32 = 3
        I64 = 4
        F32 = 5
        F64 = 6
        BOOL = 7
        BYTES = 8
        DYN = 9
        FUN = 10
        OBJ = 11
        ARRAY = 12
        TYPETYPE = 13
        REF = 14
        VIRTUAL = 15
        DYNOBJ = 16
        ABSTRACT = 17
        ENUM = 18
        NULL = 19
        METHOD = 20
        STRUCT = 21
        PACKED = 22

    def __init__(self) -&gt; None:
        self.kind = SerialisableInt()
        self.kind.length = 1
        self.definition: Optional[TypeDef] = None

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Type&#34;:
        # dbg_print(f&#34;Type @ {tell(f)}&#34;)
        self.kind.deserialise(f, length=1)
        try:
            self.TYPEDEFS[self.kind.value]
            _def = self.TYPEDEFS[self.kind.value]()
            self.definition = _def.deserialise(f)
        except IndexError:
            raise MalformedBytecode(f&#34;Invalid type kind found @{tell(f)}&#34;)
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join(
            [
                self.kind.serialise(),
                self.definition.serialise() if self.definition else b&#34;&#34;,
            ]
        )

    def __str__(self) -&gt; str:
        return f&#34;&lt;Type: {self.kind.value} ({self.definition.__class__.__name__})&gt;&#34;

    def __repr__(self) -&gt; str:
        return self.__str__()

    def str_resolve(self, code: &#34;Bytecode&#34;) -&gt; str:
        if isinstance(self.definition, Obj):
            return self.definition.str_resolve(code)
        return f&#34;&lt;Type: {self.kind.value} ({self.definition.__class__.__name__})&gt;&#34;</code></pre>
</details>
<div class="desc"><p>Type definition:</p>
<ul>
<li>kind: SerialisableInt</li>
<li>definition: TypeDef</li>
</ul></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="crashlink.core.Type.Kind"><code class="name">var <span class="ident">Kind</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="crashlink.core.Type.TYPEDEFS"><code class="name">var <span class="ident">TYPEDEFS</span> : List[type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Type.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Type" href="#crashlink.core.Type">Type</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Type&#34;:
    # dbg_print(f&#34;Type @ {tell(f)}&#34;)
    self.kind.deserialise(f, length=1)
    try:
        self.TYPEDEFS[self.kind.value]
        _def = self.TYPEDEFS[self.kind.value]()
        self.definition = _def.deserialise(f)
    except IndexError:
        raise MalformedBytecode(f&#34;Invalid type kind found @{tell(f)}&#34;)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Type.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join(
        [
            self.kind.serialise(),
            self.definition.serialise() if self.definition else b&#34;&#34;,
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Type.str_resolve"><code class="name flex">
<span>def <span class="ident">str_resolve</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_resolve(self, code: &#34;Bytecode&#34;) -&gt; str:
    if isinstance(self.definition, Obj):
        return self.definition.str_resolve(code)
    return f&#34;&lt;Type: {self.kind.value} ({self.definition.__class__.__name__})&gt;&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.TypeDef"><code class="flex name class">
<span>class <span class="ident">TypeDef</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeDef(Serialisable):
    &#34;&#34;&#34;
    Abstract class for all type definition fields.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Abstract class for all type definition fields.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="crashlink.core.Abstract" href="#crashlink.core.Abstract">Abstract</a></li>
<li><a title="crashlink.core.Enum" href="#crashlink.core.Enum">Enum</a></li>
<li><a title="crashlink.core.Fun" href="#crashlink.core.Fun">Fun</a></li>
<li><a title="crashlink.core.Null" href="#crashlink.core.Null">Null</a></li>
<li><a title="crashlink.core.Obj" href="#crashlink.core.Obj">Obj</a></li>
<li><a title="crashlink.core.Packed" href="#crashlink.core.Packed">Packed</a></li>
<li><a title="crashlink.core.Ref" href="#crashlink.core.Ref">Ref</a></li>
<li><a title="crashlink.core.Virtual" href="#crashlink.core.Virtual">Virtual</a></li>
<li>crashlink.core._NoDataType</li>
</ul>
</dd>
<dt id="crashlink.core.TypeType"><code class="flex name class">
<span>class <span class="ident">TypeType</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeType(_NoDataType):
    &#34;&#34;&#34;
    Type wrapping a type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Type wrapping a type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.U16"><code class="flex name class">
<span>class <span class="ident">U16</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class U16(_NoDataType):
    &#34;&#34;&#34;
    Unsigned 16-bit integer type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Unsigned 16-bit integer type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.U8"><code class="flex name class">
<span>class <span class="ident">U8</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class U8(_NoDataType):
    &#34;&#34;&#34;
    Unsigned 8-bit integer type, no data.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Unsigned 8-bit integer type, no data.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.VarInt"><code class="flex name class">
<span>class <span class="ident">VarInt</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VarInt(Serialisable):
    &#34;&#34;&#34;
    Variable-length integer - can be 1, 2, or 4 bytes.
    &#34;&#34;&#34;

    def __init__(self, value: int = 0):
        self.value: int = value

    def deserialise(self: T, f: BinaryIO | BytesIO) -&gt; T:
        # Read first byte - keep int.from_bytes for single byte
        b = int.from_bytes(f.read(1), &#34;big&#34;)

        # Single byte format (0xxxxxxx)
        if not (b &amp; 0x80):
            self.value = b
            return self

        # Two byte format (10xxxxxx)
        if not (b &amp; 0x40):
            # Read 2 bytes as unsigned short
            second = f.read(1)[0]  # Faster than int.from_bytes for single byte

            # Combine bytes and handle sign
            self.value = ((b &amp; 0x1F) &lt;&lt; 8) | second
            if b &amp; 0x20:
                self.value = -self.value
            return self

        # Four byte format (11xxxxxx)
        remaining = _struct_medium.unpack(b&#34;\x00&#34; + f.read(3))[0]

        # Combine all bytes and handle sign
        self.value = ((b &amp; 0x1F) &lt;&lt; 24) | remaining
        if b &amp; 0x20:
            self.value = -self.value
        return self

    def serialise(self) -&gt; bytes:
        if self.value &lt; 0:
            value = -self.value
            if value &lt; 0x2000:  # 13 bits
                return bytes([(value &gt;&gt; 8) | 0xA0, value &amp; 0xFF])
            if value &gt;= 0x20000000:
                raise MalformedBytecode(&#34;value can&#39;t be &gt;= 0x20000000&#34;)
            # Optimized 4-byte case
            return bytes(
                [
                    (value &gt;&gt; 24) | 0xE0,
                    (value &gt;&gt; 16) &amp; 0xFF,
                    (value &gt;&gt; 8) &amp; 0xFF,
                    value &amp; 0xFF,
                ]
            )

        if self.value &lt; 0x80:  # 7 bits
            return bytes([self.value])
        if self.value &lt; 0x2000:  # 13 bits
            return bytes([(self.value &gt;&gt; 8) | 0x80, self.value &amp; 0xFF])
        if self.value &gt;= 0x20000000:
            raise MalformedBytecode(&#34;value can&#39;t be &gt;= 0x20000000&#34;)
        # Optimized 4-byte case
        return bytes(
            [
                (self.value &gt;&gt; 24) | 0xC0,
                (self.value &gt;&gt; 16) &amp; 0xFF,
                (self.value &gt;&gt; 8) &amp; 0xFF,
                self.value &amp; 0xFF,
            ]
        )</code></pre>
</details>
<div class="desc"><p>Variable-length integer - can be 1, 2, or 4 bytes.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.VarInt.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self: ~T, f: typing.BinaryIO | _io.BytesIO) ‑> ~T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self: T, f: BinaryIO | BytesIO) -&gt; T:
    # Read first byte - keep int.from_bytes for single byte
    b = int.from_bytes(f.read(1), &#34;big&#34;)

    # Single byte format (0xxxxxxx)
    if not (b &amp; 0x80):
        self.value = b
        return self

    # Two byte format (10xxxxxx)
    if not (b &amp; 0x40):
        # Read 2 bytes as unsigned short
        second = f.read(1)[0]  # Faster than int.from_bytes for single byte

        # Combine bytes and handle sign
        self.value = ((b &amp; 0x1F) &lt;&lt; 8) | second
        if b &amp; 0x20:
            self.value = -self.value
        return self

    # Four byte format (11xxxxxx)
    remaining = _struct_medium.unpack(b&#34;\x00&#34; + f.read(3))[0]

    # Combine all bytes and handle sign
    self.value = ((b &amp; 0x1F) &lt;&lt; 24) | remaining
    if b &amp; 0x20:
        self.value = -self.value
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.VarInt.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    if self.value &lt; 0:
        value = -self.value
        if value &lt; 0x2000:  # 13 bits
            return bytes([(value &gt;&gt; 8) | 0xA0, value &amp; 0xFF])
        if value &gt;= 0x20000000:
            raise MalformedBytecode(&#34;value can&#39;t be &gt;= 0x20000000&#34;)
        # Optimized 4-byte case
        return bytes(
            [
                (value &gt;&gt; 24) | 0xE0,
                (value &gt;&gt; 16) &amp; 0xFF,
                (value &gt;&gt; 8) &amp; 0xFF,
                value &amp; 0xFF,
            ]
        )

    if self.value &lt; 0x80:  # 7 bits
        return bytes([self.value])
    if self.value &lt; 0x2000:  # 13 bits
        return bytes([(self.value &gt;&gt; 8) | 0x80, self.value &amp; 0xFF])
    if self.value &gt;= 0x20000000:
        raise MalformedBytecode(&#34;value can&#39;t be &gt;= 0x20000000&#34;)
    # Optimized 4-byte case
    return bytes(
        [
            (self.value &gt;&gt; 24) | 0xC0,
            (self.value &gt;&gt; 16) &amp; 0xFF,
            (self.value &gt;&gt; 8) &amp; 0xFF,
            self.value &amp; 0xFF,
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.VarInts"><code class="flex name class">
<span>class <span class="ident">VarInts</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VarInts(Serialisable):
    &#34;&#34;&#34;
    List of VarInts.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.n = VarInt()
        self.value: List[VarInt] = []

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;VarInts&#34;:
        self.n.deserialise(f)
        for _ in range(self.n.value):
            self.value.append(VarInt().deserialise(f))
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join([self.n.serialise(), b&#34;&#34;.join([value.serialise() for value in self.value])])</code></pre>
</details>
<div class="desc"><p>List of VarInts.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.VarInts.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.VarInts" href="#crashlink.core.VarInts">VarInts</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;VarInts&#34;:
    self.n.deserialise(f)
    for _ in range(self.n.value):
        self.value.append(VarInt().deserialise(f))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.VarInts.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join([self.n.serialise(), b&#34;&#34;.join([value.serialise() for value in self.value])])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Virtual"><code class="flex name class">
<span>class <span class="ident">Virtual</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Virtual(TypeDef):
    &#34;&#34;&#34;
    Virtual type, used for virtual/abstract classes.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self.nfields = VarInt()
        self.fields: List[Field] = []

    def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Virtual&#34;:
        self.nfields.deserialise(f)
        for _ in range(self.nfields.value):
            self.fields.append(Field().deserialise(f))
        return self

    def serialise(self) -&gt; bytes:
        return b&#34;&#34;.join(
            [
                self.nfields.serialise(),
                b&#34;&#34;.join([field.serialise() for field in self.fields]),
            ]
        )

    def resolve_fields(self, code: &#34;Bytecode&#34;) -&gt; List[Field]:
        return self.fields</code></pre>
</details>
<div class="desc"><p>Virtual type, used for virtual/abstract classes.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.Virtual.deserialise"><code class="name flex">
<span>def <span class="ident">deserialise</span></span>(<span>self, f: typing.BinaryIO | _io.BytesIO) ‑> <a title="crashlink.core.Virtual" href="#crashlink.core.Virtual">Virtual</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialise(self, f: BinaryIO | BytesIO) -&gt; &#34;Virtual&#34;:
    self.nfields.deserialise(f)
    for _ in range(self.nfields.value):
        self.fields.append(Field().deserialise(f))
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Virtual.resolve_fields"><code class="name flex">
<span>def <span class="ident">resolve_fields</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> List[<a title="crashlink.core.Field" href="#crashlink.core.Field">Field</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_fields(self, code: &#34;Bytecode&#34;) -&gt; List[Field]:
    return self.fields</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.core.Virtual.serialise"><code class="name flex">
<span>def <span class="ident">serialise</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialise(self) -&gt; bytes:
    return b&#34;&#34;.join(
        [
            self.nfields.serialise(),
            b&#34;&#34;.join([field.serialise() for field in self.fields]),
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.Void"><code class="flex name class">
<span>class <span class="ident">Void</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Void(_NoDataType):
    &#34;&#34;&#34;
    Void type, no data. Used to discard data (eg. reg: Void = call f@**).
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Void type, no data. Used to discard data (eg. reg: Void = call f@**).</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>crashlink.core._NoDataType</li>
<li><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="crashlink.core.bytesRef"><code class="flex name class">
<span>class <span class="ident">bytesRef</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class bytesRef(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a byte string in the bytecode.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; bytes:
        if code.bytes:
            return code.bytes.value[self.value]
        else:
            raise MalformedBytecode(&#34;No bytes block found.&#34;)</code></pre>
</details>
<div class="desc"><p>Reference to a byte string in the bytecode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.fIndex"><code class="flex name class">
<span>class <span class="ident">fIndex</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fIndex(ResolvableVarInt):
    &#34;&#34;&#34;
    Abstract class based on VarInt to represent a distinct function index instead of just an arbitrary number.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; &#34;Function|Native&#34;:
        for function in code.functions:
            if function.findex.value == self.value:
                return function
        for native in code.natives:
            if native.findex.value == self.value:
                return native
        raise MalformedBytecode(f&#34;Function index {self.value} not found.&#34;)</code></pre>
</details>
<div class="desc"><p>Abstract class based on VarInt to represent a distinct function index instead of just an arbitrary number.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.fieldRef"><code class="flex name class">
<span>class <span class="ident">fieldRef</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fieldRef(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a field in an object definition.
    &#34;&#34;&#34;

    obj: Optional[&#34;Obj|Virtual&#34;] = None

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; &#34;Field&#34;:
        if self.obj:
            return self.obj.resolve_fields(code)[self.value]
        raise ValueError(
            &#34;Cannot resolve field without context. Try setting `field.obj` to an instance of `Obj`, or use `field.resolve_obj(code, obj)` instead.&#34;
        )

    def resolve_obj(self, code: &#34;Bytecode&#34;, obj: &#34;Obj|Virtual&#34;) -&gt; &#34;Field&#34;:
        self.obj = obj
        return obj.resolve_fields(code)[self.value]</code></pre>
</details>
<div class="desc"><p>Reference to a field in an object definition.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="crashlink.core.fieldRef.obj"><code class="name">var <span class="ident">obj</span> : <a title="crashlink.core.Obj" href="#crashlink.core.Obj">Obj</a> | <a title="crashlink.core.Virtual" href="#crashlink.core.Virtual">Virtual</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.fieldRef.resolve_obj"><code class="name flex">
<span>def <span class="ident">resolve_obj</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>,<br>obj: <a title="crashlink.core.Obj" href="#crashlink.core.Obj">Obj</a>|<a title="crashlink.core.Virtual" href="#crashlink.core.Virtual">Virtual</a>) ‑> <a title="crashlink.core.Field" href="#crashlink.core.Field">Field</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_obj(self, code: &#34;Bytecode&#34;, obj: &#34;Obj|Virtual&#34;) -&gt; &#34;Field&#34;:
    self.obj = obj
    return obj.resolve_fields(code)[self.value]</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.fileRef"><code class="flex name class">
<span>class <span class="ident">fileRef</span></span>
<span>(</span><span>fid: int = 0, line: int = -1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fileRef(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a file in the debug info.
    &#34;&#34;&#34;

    def __init__(self, fid: int = 0, line: int = -1) -&gt; None:
        super().__init__(fid)
        self.line = line

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; str:
        &#34;&#34;&#34;
        Resolve to the filename of the reference.
        &#34;&#34;&#34;
        if not code.debugfiles:
            raise MalformedBytecode(&#34;No debug files found.&#34;)
        return code.debugfiles.value[self.value]

    def resolve_line(self, code: &#34;Bytecode&#34;) -&gt; int:
        &#34;&#34;&#34;
        Resolve to the line number in the file of the reference.
        &#34;&#34;&#34;
        return self.line

    def resolve_pretty(self, code: &#34;Bytecode&#34;) -&gt; str:
        &#34;&#34;&#34;
        Resolve a pretty-printed string: &lt;filename&gt;:&lt;line number&gt;
        &#34;&#34;&#34;
        return f&#34;{self.resolve(code)}:{self.line}&#34;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, fileRef):
            return NotImplemented
        return self.value == other.value and self.line == other.line</code></pre>
</details>
<div class="desc"><p>Reference to a file in the debug info.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.fileRef.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve(self, code: &#34;Bytecode&#34;) -&gt; str:
    &#34;&#34;&#34;
    Resolve to the filename of the reference.
    &#34;&#34;&#34;
    if not code.debugfiles:
        raise MalformedBytecode(&#34;No debug files found.&#34;)
    return code.debugfiles.value[self.value]</code></pre>
</details>
<div class="desc"><p>Resolve to the filename of the reference.</p></div>
</dd>
<dt id="crashlink.core.fileRef.resolve_line"><code class="name flex">
<span>def <span class="ident">resolve_line</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_line(self, code: &#34;Bytecode&#34;) -&gt; int:
    &#34;&#34;&#34;
    Resolve to the line number in the file of the reference.
    &#34;&#34;&#34;
    return self.line</code></pre>
</details>
<div class="desc"><p>Resolve to the line number in the file of the reference.</p></div>
</dd>
<dt id="crashlink.core.fileRef.resolve_pretty"><code class="name flex">
<span>def <span class="ident">resolve_pretty</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_pretty(self, code: &#34;Bytecode&#34;) -&gt; str:
    &#34;&#34;&#34;
    Resolve a pretty-printed string: &lt;filename&gt;:&lt;line number&gt;
    &#34;&#34;&#34;
    return f&#34;{self.resolve(code)}:{self.line}&#34;</code></pre>
</details>
<div class="desc"><p>Resolve a pretty-printed string: <filename>:<line number></p></div>
</dd>
</dl>
</dd>
<dt id="crashlink.core.floatRef"><code class="flex name class">
<span>class <span class="ident">floatRef</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class floatRef(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a float in the bytecode.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; SerialisableF64:
        return code.floats[self.value]</code></pre>
</details>
<div class="desc"><p>Reference to a float in the bytecode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.gIndex"><code class="flex name class">
<span>class <span class="ident">gIndex</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class gIndex(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a global object in the bytecode.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; &#34;Type&#34;:
        return code.global_types[self.value].resolve(code)

    def resolve_str(self, code: &#34;Bytecode&#34;) -&gt; str:
        return code.const_str(self.value)</code></pre>
</details>
<div class="desc"><p>Reference to a global object in the bytecode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="crashlink.core.gIndex.resolve_str"><code class="name flex">
<span>def <span class="ident">resolve_str</span></span>(<span>self,<br>code: <a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_str(self, code: &#34;Bytecode&#34;) -&gt; str:
    return code.const_str(self.value)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.intRef"><code class="flex name class">
<span>class <span class="ident">intRef</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class intRef(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to an integer in the bytecode.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; SerialisableInt:
        return code.ints[self.value]</code></pre>
</details>
<div class="desc"><p>Reference to an integer in the bytecode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.strRef"><code class="flex name class">
<span>class <span class="ident">strRef</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class strRef(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a string in the bytecode.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; str:
        return code.strings.value[self.value]</code></pre>
</details>
<div class="desc"><p>Reference to a string in the bytecode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="crashlink.core.tIndex"><code class="flex name class">
<span>class <span class="ident">tIndex</span></span>
<span>(</span><span>value: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tIndex(ResolvableVarInt):
    &#34;&#34;&#34;
    Reference to a type in the bytecode.
    &#34;&#34;&#34;

    def resolve(self, code: &#34;Bytecode&#34;) -&gt; &#34;Type&#34;:
        return code.types[self.value]</code></pre>
</details>
<div class="desc"><p>Reference to a type in the bytecode.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></li>
<li><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></li>
<li><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></b></code>:
<ul class="hlist">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="crashlink" href="index.html">crashlink</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="crashlink.core.full_func_name" href="#crashlink.core.full_func_name">full_func_name</a></code></li>
<li><code><a title="crashlink.core.get_field_for" href="#crashlink.core.get_field_for">get_field_for</a></code></li>
<li><code><a title="crashlink.core.get_proto_for" href="#crashlink.core.get_proto_for">get_proto_for</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="crashlink.core.Abstract" href="#crashlink.core.Abstract">Abstract</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Abstract.deserialise" href="#crashlink.core.Abstract.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Abstract.serialise" href="#crashlink.core.Abstract.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Array" href="#crashlink.core.Array">Array</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.Binding" href="#crashlink.core.Binding">Binding</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Binding.deserialise" href="#crashlink.core.Binding.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Binding.serialise" href="#crashlink.core.Binding.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Bool" href="#crashlink.core.Bool">Bool</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.Bytecode" href="#crashlink.core.Bytecode">Bytecode</a></code></h4>
<ul class="two-column">
<li><code><a title="crashlink.core.Bytecode.add_string" href="#crashlink.core.Bytecode.add_string">add_string</a></code></li>
<li><code><a title="crashlink.core.Bytecode.add_type" href="#crashlink.core.Bytecode.add_type">add_type</a></code></li>
<li><code><a title="crashlink.core.Bytecode.const_str" href="#crashlink.core.Bytecode.const_str">const_str</a></code></li>
<li><code><a title="crashlink.core.Bytecode.create_empty" href="#crashlink.core.Bytecode.create_empty">create_empty</a></code></li>
<li><code><a title="crashlink.core.Bytecode.deserialise" href="#crashlink.core.Bytecode.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Bytecode.find_prim_type" href="#crashlink.core.Bytecode.find_prim_type">find_prim_type</a></code></li>
<li><code><a title="crashlink.core.Bytecode.fn" href="#crashlink.core.Bytecode.fn">fn</a></code></li>
<li><code><a title="crashlink.core.Bytecode.from_bytes" href="#crashlink.core.Bytecode.from_bytes">from_bytes</a></code></li>
<li><code><a title="crashlink.core.Bytecode.from_path" href="#crashlink.core.Bytecode.from_path">from_path</a></code></li>
<li><code><a title="crashlink.core.Bytecode.g" href="#crashlink.core.Bytecode.g">g</a></code></li>
<li><code><a title="crashlink.core.Bytecode.get_test_main" href="#crashlink.core.Bytecode.get_test_main">get_test_main</a></code></li>
<li><code><a title="crashlink.core.Bytecode.init_globals" href="#crashlink.core.Bytecode.init_globals">init_globals</a></code></li>
<li><code><a title="crashlink.core.Bytecode.is_ok" href="#crashlink.core.Bytecode.is_ok">is_ok</a></code></li>
<li><code><a title="crashlink.core.Bytecode.next_free_findex" href="#crashlink.core.Bytecode.next_free_findex">next_free_findex</a></code></li>
<li><code><a title="crashlink.core.Bytecode.repair" href="#crashlink.core.Bytecode.repair">repair</a></code></li>
<li><code><a title="crashlink.core.Bytecode.section_at" href="#crashlink.core.Bytecode.section_at">section_at</a></code></li>
<li><code><a title="crashlink.core.Bytecode.serialise" href="#crashlink.core.Bytecode.serialise">serialise</a></code></li>
<li><code><a title="crashlink.core.Bytecode.set_meta" href="#crashlink.core.Bytecode.set_meta">set_meta</a></code></li>
<li><code><a title="crashlink.core.Bytecode.t" href="#crashlink.core.Bytecode.t">t</a></code></li>
<li><code><a title="crashlink.core.Bytecode.track_section" href="#crashlink.core.Bytecode.track_section">track_section</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Bytes" href="#crashlink.core.Bytes">Bytes</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.BytesBlock" href="#crashlink.core.BytesBlock">BytesBlock</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.BytesBlock.deserialise" href="#crashlink.core.BytesBlock.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.BytesBlock.serialise" href="#crashlink.core.BytesBlock.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Constant" href="#crashlink.core.Constant">Constant</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Constant.deserialise" href="#crashlink.core.Constant.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Constant.serialise" href="#crashlink.core.Constant.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.DebugInfo" href="#crashlink.core.DebugInfo">DebugInfo</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.DebugInfo.deserialise" href="#crashlink.core.DebugInfo.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.DebugInfo.serialise" href="#crashlink.core.DebugInfo.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Dyn" href="#crashlink.core.Dyn">Dyn</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.DynObj" href="#crashlink.core.DynObj">DynObj</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.Enum" href="#crashlink.core.Enum">Enum</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Enum.deserialise" href="#crashlink.core.Enum.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Enum.serialise" href="#crashlink.core.Enum.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.EnumConstruct" href="#crashlink.core.EnumConstruct">EnumConstruct</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.EnumConstruct.deserialise" href="#crashlink.core.EnumConstruct.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.EnumConstruct.serialise" href="#crashlink.core.EnumConstruct.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.F32" href="#crashlink.core.F32">F32</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.F64" href="#crashlink.core.F64">F64</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.Field" href="#crashlink.core.Field">Field</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Field.deserialise" href="#crashlink.core.Field.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Field.serialise" href="#crashlink.core.Field.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Fun" href="#crashlink.core.Fun">Fun</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Fun.deserialise" href="#crashlink.core.Fun.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Fun.serialise" href="#crashlink.core.Fun.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Function" href="#crashlink.core.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Function.deserialise" href="#crashlink.core.Function.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Function.insert_op" href="#crashlink.core.Function.insert_op">insert_op</a></code></li>
<li><code><a title="crashlink.core.Function.resolve_file" href="#crashlink.core.Function.resolve_file">resolve_file</a></code></li>
<li><code><a title="crashlink.core.Function.serialise" href="#crashlink.core.Function.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.I32" href="#crashlink.core.I32">I32</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.I64" href="#crashlink.core.I64">I64</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.InlineBool" href="#crashlink.core.InlineBool">InlineBool</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.InlineBool.deserialise" href="#crashlink.core.InlineBool.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.InlineBool.serialise" href="#crashlink.core.InlineBool.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Method" href="#crashlink.core.Method">Method</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.Native" href="#crashlink.core.Native">Native</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Native.deserialise" href="#crashlink.core.Native.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Native.serialise" href="#crashlink.core.Native.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Null" href="#crashlink.core.Null">Null</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Null.deserialise" href="#crashlink.core.Null.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Null.serialise" href="#crashlink.core.Null.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Obj" href="#crashlink.core.Obj">Obj</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Obj.deserialise" href="#crashlink.core.Obj.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Obj.resolve_fields" href="#crashlink.core.Obj.resolve_fields">resolve_fields</a></code></li>
<li><code><a title="crashlink.core.Obj.serialise" href="#crashlink.core.Obj.serialise">serialise</a></code></li>
<li><code><a title="crashlink.core.Obj.str_resolve" href="#crashlink.core.Obj.str_resolve">str_resolve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Opcode" href="#crashlink.core.Opcode">Opcode</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Opcode.TYPE_MAP" href="#crashlink.core.Opcode.TYPE_MAP">TYPE_MAP</a></code></li>
<li><code><a title="crashlink.core.Opcode.deserialise" href="#crashlink.core.Opcode.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Opcode.serialise" href="#crashlink.core.Opcode.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Packed" href="#crashlink.core.Packed">Packed</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Packed.deserialise" href="#crashlink.core.Packed.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Packed.serialise" href="#crashlink.core.Packed.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Proto" href="#crashlink.core.Proto">Proto</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Proto.deserialise" href="#crashlink.core.Proto.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Proto.serialise" href="#crashlink.core.Proto.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.RawData" href="#crashlink.core.RawData">RawData</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.RawData.deserialise" href="#crashlink.core.RawData.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.RawData.serialise" href="#crashlink.core.RawData.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Ref" href="#crashlink.core.Ref">Ref</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Ref.deserialise" href="#crashlink.core.Ref.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Ref.serialise" href="#crashlink.core.Ref.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Reg" href="#crashlink.core.Reg">Reg</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.Regs" href="#crashlink.core.Regs">Regs</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Regs.deserialise" href="#crashlink.core.Regs.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Regs.serialise" href="#crashlink.core.Regs.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.ResolvableVarInt" href="#crashlink.core.ResolvableVarInt">ResolvableVarInt</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.ResolvableVarInt.resolve" href="#crashlink.core.ResolvableVarInt.resolve">resolve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Serialisable" href="#crashlink.core.Serialisable">Serialisable</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Serialisable.deserialise" href="#crashlink.core.Serialisable.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Serialisable.serialise" href="#crashlink.core.Serialisable.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.SerialisableF64" href="#crashlink.core.SerialisableF64">SerialisableF64</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.SerialisableF64.deserialise" href="#crashlink.core.SerialisableF64.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.SerialisableF64.serialise" href="#crashlink.core.SerialisableF64.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.SerialisableInt" href="#crashlink.core.SerialisableInt">SerialisableInt</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.SerialisableInt.deserialise" href="#crashlink.core.SerialisableInt.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.SerialisableInt.serialise" href="#crashlink.core.SerialisableInt.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.StringsBlock" href="#crashlink.core.StringsBlock">StringsBlock</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.StringsBlock.deserialise" href="#crashlink.core.StringsBlock.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.StringsBlock.find_or_add" href="#crashlink.core.StringsBlock.find_or_add">find_or_add</a></code></li>
<li><code><a title="crashlink.core.StringsBlock.serialise" href="#crashlink.core.StringsBlock.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Struct" href="#crashlink.core.Struct">Struct</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.Type" href="#crashlink.core.Type">Type</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Type.Kind" href="#crashlink.core.Type.Kind">Kind</a></code></li>
<li><code><a title="crashlink.core.Type.TYPEDEFS" href="#crashlink.core.Type.TYPEDEFS">TYPEDEFS</a></code></li>
<li><code><a title="crashlink.core.Type.deserialise" href="#crashlink.core.Type.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Type.serialise" href="#crashlink.core.Type.serialise">serialise</a></code></li>
<li><code><a title="crashlink.core.Type.str_resolve" href="#crashlink.core.Type.str_resolve">str_resolve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.TypeDef" href="#crashlink.core.TypeDef">TypeDef</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.TypeType" href="#crashlink.core.TypeType">TypeType</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.U16" href="#crashlink.core.U16">U16</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.U8" href="#crashlink.core.U8">U8</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.VarInt" href="#crashlink.core.VarInt">VarInt</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.VarInt.deserialise" href="#crashlink.core.VarInt.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.VarInt.serialise" href="#crashlink.core.VarInt.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.VarInts" href="#crashlink.core.VarInts">VarInts</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.VarInts.deserialise" href="#crashlink.core.VarInts.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.VarInts.serialise" href="#crashlink.core.VarInts.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Virtual" href="#crashlink.core.Virtual">Virtual</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.Virtual.deserialise" href="#crashlink.core.Virtual.deserialise">deserialise</a></code></li>
<li><code><a title="crashlink.core.Virtual.resolve_fields" href="#crashlink.core.Virtual.resolve_fields">resolve_fields</a></code></li>
<li><code><a title="crashlink.core.Virtual.serialise" href="#crashlink.core.Virtual.serialise">serialise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.Void" href="#crashlink.core.Void">Void</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.bytesRef" href="#crashlink.core.bytesRef">bytesRef</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.fIndex" href="#crashlink.core.fIndex">fIndex</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.fieldRef" href="#crashlink.core.fieldRef">fieldRef</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.fieldRef.obj" href="#crashlink.core.fieldRef.obj">obj</a></code></li>
<li><code><a title="crashlink.core.fieldRef.resolve_obj" href="#crashlink.core.fieldRef.resolve_obj">resolve_obj</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.fileRef" href="#crashlink.core.fileRef">fileRef</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.fileRef.resolve" href="#crashlink.core.fileRef.resolve">resolve</a></code></li>
<li><code><a title="crashlink.core.fileRef.resolve_line" href="#crashlink.core.fileRef.resolve_line">resolve_line</a></code></li>
<li><code><a title="crashlink.core.fileRef.resolve_pretty" href="#crashlink.core.fileRef.resolve_pretty">resolve_pretty</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.floatRef" href="#crashlink.core.floatRef">floatRef</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.gIndex" href="#crashlink.core.gIndex">gIndex</a></code></h4>
<ul class="">
<li><code><a title="crashlink.core.gIndex.resolve_str" href="#crashlink.core.gIndex.resolve_str">resolve_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="crashlink.core.intRef" href="#crashlink.core.intRef">intRef</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.strRef" href="#crashlink.core.strRef">strRef</a></code></h4>
</li>
<li>
<h4><code><a title="crashlink.core.tIndex" href="#crashlink.core.tIndex">tIndex</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
