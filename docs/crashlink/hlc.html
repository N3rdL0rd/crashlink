<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>crashlink.hlc API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>crashlink.hlc</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="crashlink.hlc.cast_fun"><code class="name flex">
<span>def <span class="ident">cast_fun</span></span>(<span>code: Bytecode, func_ptr_expr: str, ret_type: tIndex, args_types: List[tIndex]) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cast_fun(code: Bytecode, func_ptr_expr: str, ret_type: tIndex, args_types: List[tIndex]) -&gt; str:
    &#34;&#34;&#34;Generates a C cast for a function pointer.&#34;&#34;&#34;
    ret_t_str = ctype(code, ret_type.resolve(code), ret_type.value)
    args_t_str = &#34;, &#34;.join(ctype(code, t.resolve(code), t.value) for t in args_types) or &#34;void&#34;
    return f&#34;(({ret_t_str} (*)({args_t_str})){func_ptr_expr})&#34;</code></pre>
</details>
<div class="desc"><p>Generates a C cast for a function pointer.</p></div>
</dd>
<dt id="crashlink.hlc.code_to_c"><code class="name flex">
<span>def <span class="ident">code_to_c</span></span>(<span>code: Bytecode) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_to_c(code: Bytecode) -&gt; str:
    &#34;&#34;&#34;
    Translates a loaded Bytecode object into a single C source file.
    &#34;&#34;&#34;
    res = []

    def line(*args: Any) -&gt; None:
        res.append(&#34; &#34;.join(str(arg) for arg in args))

    sec: Callable[[str], None] = lambda section: res.append(f&#34;\n\n/*---------- {section} ----------*/\n&#34;)

    line(&#34;// Generated by crashlink&#34;)
    line(
        &#34;// Compile with `$(CC) &lt;this_file.c&gt; path/to/hashlink/bin/include/hlc_main.c -Wno-incompatible-pointer-types -o Arithmetic -Ipath/to/hashlink/bin/include -Lpath/to/hashlink/bin -lhl -ldbghelp` ;)&#34;
    )
    line(&#34;#include &lt;hlc.h&gt;&#34;)

    sec(&#34;Natives &amp; Abstracts Forward Declarations&#34;)
    res += generate_natives(code)
    res.append(&#34;void hl_entry_point();&#34;)

    sec(&#34;Structs&#34;)
    res += generate_structs(code)

    sec(&#34;Types&#34;)
    res += generate_types(code)

    sec(&#34;Globals &amp; Strings&#34;)
    res += generate_globals(code)

    sec(&#34;Dummy label call&#34;)
    line(&#34;void dummycall_label() { /* dummy */ }&#34;)

    sec(&#34;Functions&#34;)
    res += generate_functions(code)

    sec(&#34;Reflection&#34;)
    res += generate_reflection(code)

    sec(&#34;Function Tables&#34;)
    res += generate_function_tables(code)

    sec(&#34;Hashes&#34;)
    res += generate_hashes(code)

    sec(&#34;Entrypoint&#34;)
    res += generate_entry(code)

    if unknown_ops:
        print(f&#34;Warning: {len(unknown_ops)} unknown operations encountered during function generation.&#34;)
        print(unknown_ops)

    return &#34;\n&#34;.join(res)</code></pre>
</details>
<div class="desc"><p>Translates a loaded Bytecode object into a single C source file.</p></div>
</dd>
<dt id="crashlink.hlc.ctype"><code class="name flex">
<span>def <span class="ident">ctype</span></span>(<span>code: Bytecode, typ: Type, i: int) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctype(code: Bytecode, typ: Type, i: int) -&gt; str:
    &#34;&#34;&#34;Converts a Type object into a C type string representation, including pointers.&#34;&#34;&#34;
    base_name, ptr_level = _ctype_no_ptr(code, typ, i)
    return base_name + (&#34;*&#34; * ptr_level) if ptr_level &gt; 0 else base_name</code></pre>
</details>
<div class="desc"><p>Converts a Type object into a C type string representation, including pointers.</p></div>
</dd>
<dt id="crashlink.hlc.ctype_no_ptr"><code class="name flex">
<span>def <span class="ident">ctype_no_ptr</span></span>(<span>code: Bytecode, typ: Type, i: int) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctype_no_ptr(code: Bytecode, typ: Type, i: int) -&gt; str:
    &#34;&#34;&#34;Converts a Type object into a C type string representation, excluding pointers.&#34;&#34;&#34;
    base_name, _ = _ctype_no_ptr(code, typ, i)
    return base_name</code></pre>
</details>
<div class="desc"><p>Converts a Type object into a C type string representation, excluding pointers.</p></div>
</dd>
<dt id="crashlink.hlc.dyn_value_field"><code class="name flex">
<span>def <span class="ident">dyn_value_field</span></span>(<span>typ: Type) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dyn_value_field(typ: Type) -&gt; str:
    &#34;&#34;&#34;
    Returns the name of the C union field used to store a value of a given type
    within a vdynamic struct.
    &#34;&#34;&#34;
    dfn = typ.definition
    if isinstance(dfn, (U8, U16, I32)):
        return &#34;i&#34;
    if isinstance(dfn, I64):
        return &#34;i64&#34;
    if isinstance(dfn, F32):
        return &#34;f&#34;
    if isinstance(dfn, F64):
        return &#34;d&#34;
    if isinstance(dfn, Bool):
        return &#34;b&#34;
    # All other types (HBytes, HDyn, HFun, HObj, etc.) are pointers.
    return &#34;ptr&#34;</code></pre>
</details>
<div class="desc"><p>Returns the name of the C union field used to store a value of a given type
within a vdynamic struct.</p></div>
</dd>
<dt id="crashlink.hlc.generate_entry"><code class="name flex">
<span>def <span class="ident">generate_entry</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_entry(code: Bytecode) -&gt; List[str]:
    &#34;&#34;&#34;Generates the C entry point for the HLC module.&#34;&#34;&#34;
    res = []
    indent = Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    line(&#34;void hl_entry_point() {&#34;)
    with indent:
        line(&#34;hl_module_context ctx;&#34;)
        line(&#34;hl_alloc_init(&amp;ctx.alloc);&#34;)
        line(&#34;ctx.functions_ptrs = hl_functions_ptrs;&#34;)
        line(&#34;ctx.functions_types = hl_functions_types;&#34;)
        line(&#34;hl_init_types(&amp;ctx);&#34;)
        line(&#34;hl_init_hashes();&#34;)
        line(&#34;hl_init_roots();&#34;)
        line(f&#34;f${code.entrypoint.value}();&#34;)
    line(&#34;}&#34;)
    return res</code></pre>
</details>
<div class="desc"><p>Generates the C entry point for the HLC module.</p></div>
</dd>
<dt id="crashlink.hlc.generate_function_tables"><code class="name flex">
<span>def <span class="ident">generate_function_tables</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_function_tables(code: Bytecode) -&gt; List[str]:
    &#34;&#34;&#34;Generates the hl_functions_ptrs and hl_functions_types C arrays.&#34;&#34;&#34;
    res = []
    indent = Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    if not code.functions and not code.natives:
        max_findex = -1
    else:
        all_findexes = [f.findex.value for f in code.functions] + [n.findex.value for n in code.natives]
        max_findex = max(all_findexes)

    total_functions = max_findex + 1

    line(&#34;void *hl_functions_ptrs[] = {&#34;)
    with indent:
        ptrs = []
        for i in range(total_functions):
            ptrs.append(f&#34;(void*)f${i}&#34;)
        line(&#34;,\n&#34;.join(ptrs))
    line(&#34;};&#34;)
    line(&#34;&#34;)

    line(&#34;hl_type *hl_functions_types[] = {&#34;)
    with indent:
        types = []
        for i in range(total_functions):
            try:
                func_or_native = code.fn(i)
                type_index = func_or_native.type.value
                types.append(f&#34;&amp;t${type_index}&#34;)
            except ValueError:
                types.append(&#34;&amp;hlt_void&#34;)
        line(&#34;,\n&#34;.join(types))
    line(&#34;};&#34;)

    return res</code></pre>
</details>
<div class="desc"><p>Generates the hl_functions_ptrs and hl_functions_types C arrays.</p></div>
</dd>
<dt id="crashlink.hlc.generate_functions"><code class="name flex">
<span>def <span class="ident">generate_functions</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_functions(code: Bytecode) -&gt; List[str]:
    global unknown_ops

    res = []
    indent = Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    def opline(idx: int, *args: Any) -&gt; None:
        res.append(indent.current_indent + f&#34;Op_{idx}: &#34; + &#34; &#34;.join(str(arg) for arg in args))

    def regstr(r: Reg | int) -&gt; str:
        return f&#34;r{r}&#34;

    def cast_fun(code: Bytecode, func_ptr_expr: str, ret_type: tIndex, args_types: List[tIndex]) -&gt; str:
        &#34;&#34;&#34;Generates a C cast for a function pointer.&#34;&#34;&#34;
        ret_t_str = ctype(code, ret_type.resolve(code), ret_type.value)
        args_t_str = &#34;, &#34;.join(ctype(code, t.resolve(code), t.value) for t in args_types) or &#34;void&#34;
        return f&#34;(({ret_t_str} (*)({args_t_str})){func_ptr_expr})&#34;

    def rcast(code: Bytecode, reg: Reg, target_type_idx: tIndex, function: Function) -&gt; str:
        &#34;&#34;&#34;Generates a C-style cast for a register if its type differs from the target.&#34;&#34;&#34;
        reg_type_idx = function.regs[reg.value]
        reg_type_def = reg_type_idx.resolve(code).definition
        target_type_def = target_type_idx.resolve(code).definition

        if reg_type_idx.value == target_type_idx.value:
            return regstr(reg)

        if isinstance(reg_type_def, Packed) and isinstance(target_type_def, Struct):
            target_ctype = ctype(code, target_type_idx.resolve(code), target_type_idx.value)
            return f&#34;(*({target_ctype}*){regstr(reg)})&#34;

        # Default cast
        target_ctype = ctype(code, target_type_idx.resolve(code), target_type_idx.value)
        return f&#34;(({target_ctype}){regstr(reg)})&#34;

    def compare_op(
        op_name: str, df: Dict[str, Any], function: Function, code: Bytecode, i: int
    ) -&gt; Tuple[bool, bool, str]:
        &#34;&#34;&#34;
        Generates the C code for a comparison-based jump instruction.
        Replicates the logic of the `compare_op` function in the OCaml source.

        Returns:
            A tuple (has_dst, no_semi, C_code_string). For jumps, this is always (False, True, code).
        &#34;&#34;&#34;
        try:
            comp_op_str = COMP_OP_MAP[op_name]
        except KeyError:
            raise NotImplementedError(f&#34;Comparison operator for {op_name} not defined.&#34;)

        reg_a_idx, reg_b_idx = df[&#34;a&#34;], df[&#34;b&#34;]
        reg_a, reg_b = regstr(reg_a_idx), regstr(reg_b_idx)
        label = f&#34;Op_{df[&#39;offset&#39;].value + i + 1}&#34;  # HL op offsets are relative to the *next* instruction

        regs = function.regs
        type_a_def = regs[reg_a_idx.value].resolve(code).definition
        type_b_def = regs[reg_b_idx.value].resolve(code).definition

        def phys_compare() -&gt; str:
            &#34;&#34;&#34;Generates a direct physical/pointer comparison in C.&#34;&#34;&#34;
            target_type_idx = regs[reg_a_idx.value]
            casted_b = rcast(code, reg_b_idx, target_type_idx, function)
            return f&#34;if ({reg_a} {comp_op_str} {casted_b}) goto {label};&#34;

        # -- Primitive Types (Ints, Floats, Bools) --
        if isinstance(type_a_def, (U8, U16, I32, F32, F64, Bool, I64)) and isinstance(
            type_b_def, (U8, U16, I32, F32, F64, Bool, I64)
        ):
            return False, True, phys_compare()

        # -- Simple Pointer-based Types (Bytes, Arrays, Structs, etc.) --
        # These are compared by their memory address.
        if isinstance(type_a_def, (Bytes, Array, Struct, Enum, DynObj, Abstract)) and type(type_a_def) == type(
            type_b_def
        ):
            return False, True, phys_compare()

        # -- HType --
        if isinstance(type_a_def, TypeType) and isinstance(type_b_def, TypeType):
            # hl_same_type returns 0 for equality.
            return False, True, f&#34;if (hl_same_type({reg_a}, {reg_b}) {comp_op_str} 0) goto {label};&#34;

        # -- HNull&lt;T&gt; --
        if isinstance(type_a_def, Null) and isinstance(type_b_def, Null):
            assert isinstance(type_a_def.type, tIndex)
            inner_type = type_a_def.type.resolve(code)
            field = dyn_value_field(inner_type)
            pcompare = f&#34;({reg_a}-&gt;v.{field} {comp_op_str} {reg_b}-&gt;v.{field})&#34;

            if op_name == &#34;JEq&#34;:
                return False, True, f&#34;if ({reg_a} == {reg_b} || ({reg_a} &amp;&amp; {reg_b} &amp;&amp; {pcompare})) goto {label};&#34;
            if op_name == &#34;JNotEq&#34;:
                return False, True, f&#34;if ({reg_a} != {reg_b} &amp;&amp; (!{reg_a} || !{reg_b} || {pcompare})) goto {label};&#34;
            # For &lt;, &lt;=, &gt;, &gt;=, both must be non-null.
            return False, True, f&#34;if ({reg_a} &amp;&amp; {reg_b} &amp;&amp; {pcompare}) goto {label};&#34;

        # -- Dynamic or Function types --
        if isinstance(type_a_def, (Dyn, Fun)) or isinstance(type_b_def, (Dyn, Fun)):
            inv = &#34;&amp;&amp; i != hl_invalid_comparison &#34; if op_name in (&#34;JSGt&#34;, &#34;JSGte&#34;) else &#34;&#34;
            return (
                False,
                True,
                f&#34;{{ int i = hl_dyn_compare((vdynamic*){reg_a}, (vdynamic*){reg_b}); if (i {comp_op_str} 0 {inv}) goto {label}; }}&#34;,
            )

        # -- HObj vs HObj --
        if isinstance(type_a_def, Obj) and isinstance(type_b_def, Obj):
            compare_fid = -1
            # Find the __compare function if it exists on the prototype of type A
            for proto in type_a_def.protos:
                if proto.name.resolve(code) == &#34;__compare&#34;:
                    compare_fid = proto.findex.value
                    break

            if compare_fid == -1:
                return False, True, phys_compare()
            else:
                # Note: The OCaml code uses a global function table `funname fid`. We use `f${fid}`.
                compare_call = f&#34;f${compare_fid}({reg_a}, (vdynamic*){reg_b})&#34;
                if op_name == &#34;JEq&#34;:
                    return (
                        False,
                        True,
                        f&#34;if ({reg_a} == {reg_b} || ({reg_a} &amp;&amp; {reg_b} &amp;&amp; {compare_call} == 0)) goto {label};&#34;,
                    )
                if op_name == &#34;JNotEq&#34;:
                    return (
                        False,
                        True,
                        f&#34;if ({reg_a} != {reg_b} &amp;&amp; (!{reg_a} || !{reg_b} || {compare_call} != 0)) goto {label};&#34;,
                    )
                return False, True, f&#34;if ({reg_a} &amp;&amp; {reg_b} &amp;&amp; {compare_call} {comp_op_str} 0) goto {label};&#34;

        # -- HVirtual vs HVirtual --
        if isinstance(type_a_def, Virtual) and isinstance(type_b_def, Virtual):
            if op_name == &#34;JEq&#34;:
                return (
                    False,
                    True,
                    f&#34;if ({reg_a} == {reg_b} || ({reg_a} &amp;&amp; {reg_b} &amp;&amp; {reg_a}-&gt;value &amp;&amp; {reg_b}-&gt;value &amp;&amp; {reg_a}-&gt;value == {reg_b}-&gt;value)) goto {label};&#34;,
                )
            if op_name == &#34;JNotEq&#34;:
                return (
                    False,
                    True,
                    f&#34;if ({reg_a} != {reg_b} &amp;&amp; (!{reg_a} || !{reg_b} || !{reg_a}-&gt;value || !{reg_b}-&gt;value || {reg_a}-&gt;value != {reg_b}-&gt;value)) goto {label};&#34;,
                )
            # Other comparisons are not supported for Virtuals
            return False, True, f&#34;/* JSLt/JSGt on Virtual not supported */&#34;

        # -- HVirtual vs HObj --
        if isinstance(type_a_def, Virtual) and isinstance(type_b_def, Obj):
            if op_name == &#34;JEq&#34;:
                return (
                    False,
                    True,
                    f&#34;if ({reg_a} ? ({reg_b} &amp;&amp; {reg_a}-&gt;value == (vdynamic*){reg_b}) : ({reg_b} == NULL)) goto {label};&#34;,
                )
            if op_name == &#34;JNotEq&#34;:
                return (
                    False,
                    True,
                    f&#34;if ({reg_a} ? ({reg_b} == NULL || {reg_a}-&gt;value != (vdynamic*){reg_b}) : ({reg_b} != NULL)) goto {label};&#34;,
                )
            return False, True, f&#34;/* JSLt/JSGt on Virtual vs Obj not supported */&#34;

        # -- HObj vs HVirtual (recursive call with swapped operands) --
        if isinstance(type_a_def, Obj) and isinstance(type_b_def, Virtual):
            swapped_op = SWAP_OP_MAP[op_name]
            swapped_df = df.copy()
            swapped_df[&#34;a&#34;], swapped_df[&#34;b&#34;] = df[&#34;b&#34;], df[&#34;a&#34;]
            return compare_op(swapped_op, swapped_df, function, code, i)

        # Fallback for any unhandled combination
        return (
            False,
            True,
            f&#34;/* UNHANDLED COMPARISON: {type(type_a_def).__name__} vs {type(type_b_def).__name__} */\n{indent.current_indent}{phys_compare()}&#34;,
        )

    def dyn_prefix(typ: Type) -&gt; str:
        &#34;&#34;&#34;
        Returns the one-char prefix for dynamic operations based on type.
        &#39;i&#39; for int-like, &#39;f&#39; for f32, &#39;d&#39; for f64, &#39;i64&#39; for i64, &#39;p&#39; for pointers.
        &#34;&#34;&#34;
        kind = typ.kind.value
        if kind in {Type.Kind.U8.value, Type.Kind.U16.value, Type.Kind.I32.value, Type.Kind.BOOL.value}:
            return &#34;i&#34;
        if kind == Type.Kind.F32.value:
            return &#34;f&#34;
        if kind == Type.Kind.F64.value:
            return &#34;d&#34;
        if kind == Type.Kind.I64.value:
            return &#34;i64&#34;
        return &#34;p&#34;

    def enum_constr_type(code: Bytecode, e: Enum, cid: int) -&gt; str:
        &#34;&#34;&#34;
        Generates the C type name for a specific enum constructor struct.
        Example: my.pack.MyEnum constructor `MyValue(a:Int)` might become `my_pack_MyEnum_MyValue`.
        &#34;&#34;&#34;
        constr = e.constructs[cid]
        if not constr.params:
            return &#34;venum&#34;

        enum_name_str = e.name.resolve(code)
        c_enum_name = sanitize_ident(enum_name_str.replace(&#34;.&#34;, &#34;__&#34;))

        constr_name_str = constr.name.resolve(code)
        c_constr_name = sanitize_ident(constr_name_str)

        if not enum_name_str:
            return f&#34;Enum_{c_enum_name}&#34;

        if not constr_name_str:
            return c_enum_name

        return f&#34;{c_enum_name}_{c_constr_name}&#34;

    for function in tqdm(code.functions, desc=&#34;Generating function prototypes&#34;) if USE_TQDM else code.functions:  # pyright: ignore[reportPossiblyUnboundVariable]
        fun = function.type.resolve(code).definition
        assert isinstance(fun, Fun), (
            f&#34;Expected function type to be Fun, got {type(fun).__name__}. This should never happen.&#34;
        )
        ret_t = ctype(code, fun.ret.resolve(code), fun.ret.value)
        args_t = [ctype(code, arg.resolve(code), arg.value) for arg in fun.args]
        args = [f&#34;{t}&#34; for t in args_t]
        args_str = &#34;, &#34;.join(args) if args else &#34;void&#34;
        line(f&#34;{ret_t} f${function.findex.value}({args_str}); /* t${function.type.value} */&#34;)

    for function in tqdm(code.functions, desc=&#34;Generating functions&#34;) if USE_TQDM else code.functions:  # pyright: ignore[reportPossiblyUnboundVariable]
        fun = function.type.resolve(code).definition
        assert isinstance(fun, Fun), (
            f&#34;Expected function type to be Fun, got {type(fun).__name__}. This should never happen.&#34;
        )
        ret_t = ctype(code, fun.ret.resolve(code), fun.ret.value)
        args_t = [ctype(code, arg.resolve(code), arg.value) for arg in fun.args]
        args = [f&#34;{t} r{i}&#34; for i, t in enumerate(args_t)]
        args_str = &#34;, &#34;.join(args) if args else &#34;void&#34;
        line(f&#34;{ret_t} f${function.findex.value}({args_str}) {{&#34;)
        closure_id = 0

        max_trap_depth = 0
        current_trap_depth = 0
        for op in function.ops:
            if op.op == &#34;Trap&#34;:
                current_trap_depth += 1
                if current_trap_depth &gt; max_trap_depth:
                    max_trap_depth = current_trap_depth
            elif op.op == &#34;EndTrap&#34;:
                current_trap_depth -= 1

        if max_trap_depth &gt; 0:
            line(&#34;&#34;)  # cosmetic newline
            for i in range(max_trap_depth):
                line(f&#34;hl_trap_ctx trap${i};&#34;)

        trap_depth = 0
        fn_start = len(res)
        with indent:
            for i, reg in enumerate(function.regs[len(args) :]):
                reg_idx = i + len(args)
                if reg.resolve(code).kind.value == Type.Kind.VOID.value:
                    line(f&#34;// void r{reg_idx}&#34;)
                    continue  # void is for explicit discard
                reg_type = ctype(code, reg.resolve(code), reg.value)
                line(f&#34;{reg_type} r{reg_idx}; &#34;)

            for i, op in enumerate(function.ops):
                # oh god, here we go
                df = op.df
                rhs = &#34;&#34;
                has_dst = &#34;dst&#34; in df
                no_semi = False

                match op.op:
                    case &#34;Mov&#34;:
                        rhs = f&#34;r{df[&#39;src&#39;]}&#34;
                    case &#34;Int&#34;:
                        rhs = f&#34;{code.ints[df[&#39;ptr&#39;].value].value}&#34;
                    case &#34;Float&#34;:
                        rhs = f&#34;{code.floats[df[&#39;ptr&#39;].value].value}&#34;
                    case &#34;Bool&#34;:
                        rhs = &#34;true&#34; if df[&#34;value&#34;] else &#34;false&#34;
                    case &#34;Bytes&#34;:
                        # TODO not sure this is right - might be bytes pool past v5?
                        rhs = f&#39;(vbyte*)USTR(&#34;{code.strings.value[df[&#34;ptr&#34;].value]}&#34;)&#39;
                    case &#34;String&#34;:
                        rhs = f&#39;(vbyte*)USTR(&#34;{code.strings.value[df[&#34;ptr&#34;].value]}&#34;)&#39;
                    case &#34;Null&#34;:
                        rhs = &#34;NULL&#34;
                    case &#34;Add&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} + r{df[&#39;b&#39;]}&#34;
                    case &#34;Sub&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} - r{df[&#39;b&#39;]}&#34;
                    case &#34;Mul&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} * r{df[&#39;b&#39;]}&#34;
                    case &#34;SDiv&#34;:
                        rtype = function.regs[df[&#34;dst&#34;].value].resolve(code).kind.value
                        if rtype in {Type.Kind.U8.value, Type.Kind.U16.value, Type.Kind.I32.value}:
                            rhs = f&#34;(r{df[&#39;b&#39;]} == 0 || r{df[&#39;b&#39;]} == -1) ? r{df[&#39;a&#39;]} * r{df[&#39;b&#39;]} : r{df[&#39;a&#39;]} / r{df[&#39;b&#39;]}&#34;
                        else:
                            rhs = f&#34;r{df[&#39;a&#39;]} / r{df[&#39;b&#39;]}&#34;
                    case &#34;UDiv&#34;:
                        rhs = f&#34;(r{df[&#39;b&#39;]} == 0) ? 0 : ((unsigned)r{df[&#39;a&#39;]}) / ((unsigned)r{df[&#39;b&#39;]})&#34;
                    case &#34;SMod&#34;:
                        rtype = function.regs[df[&#34;dst&#34;].value].resolve(code).kind.value
                        if rtype in {Type.Kind.U8.value, Type.Kind.U16.value, Type.Kind.I32.value}:
                            rhs = f&#34;(r{df[&#39;b&#39;]} == 0 || r{df[&#39;b&#39;]} == -1) ? 0 : r{df[&#39;a&#39;]} % r{df[&#39;b&#39;]}&#34;
                        elif rtype == Type.Kind.F32.value:
                            rhs = f&#34;fmodf(r{df[&#39;a&#39;]}, r{df[&#39;b&#39;]})&#34;
                        elif rtype == Type.Kind.F64.value:
                            rhs = f&#34;fmod(r{df[&#39;a&#39;]}, r{df[&#39;b&#39;]})&#34;
                        else:
                            raise MalformedBytecode(
                                f&#34;Unsupported SMod type: {rtype} at op {i} in function {function.findex}&#34;
                            )
                    case &#34;UMod&#34;:
                        rhs = f&#34;(r{df[&#39;b&#39;]} == 0) ? 0 : ((unsigned)r{df[&#39;a&#39;]}) % ((unsigned)r{df[&#39;b&#39;]})&#34;
                    case &#34;Shl&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} &lt;&lt; r{df[&#39;b&#39;]}&#34;
                    case &#34;SShr&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} &gt;&gt; r{df[&#39;b&#39;]}&#34;
                    case &#34;UShr&#34;:
                        rtype = function.regs[df[&#34;dst&#34;].value].resolve(code).kind.value
                        if rtype == Type.Kind.I64.value:
                            rhs = f&#34;((uint64)r{df[&#39;a&#39;]}) &gt;&gt; r{df[&#39;b&#39;]}&#34;
                        else:
                            rhs = f&#34;((unsigned)r{df[&#39;a&#39;]}) &gt;&gt; r{df[&#39;b&#39;]}&#34;
                    case &#34;And&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} &amp; r{df[&#39;b&#39;]}&#34;
                    case &#34;Or&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} | r{df[&#39;b&#39;]}&#34;
                    case &#34;Xor&#34;:
                        rhs = f&#34;r{df[&#39;a&#39;]} ^ r{df[&#39;b&#39;]}&#34;
                    case &#34;Neg&#34;:
                        rhs = f&#34;-r{df[&#39;src&#39;]}&#34;
                    case &#34;Not&#34;:
                        rhs = f&#34;!r{df[&#39;src&#39;]}&#34;
                    case &#34;Incr&#34;:
                        rhs = f&#34;++r{df[&#39;dst&#39;]}&#34;
                        has_dst = False
                    case &#34;Decr&#34;:
                        rhs = f&#34;--r{df[&#39;dst&#39;]}&#34;
                        has_dst = False
                    case &#34;Call0&#34; | &#34;Call1&#34; | &#34;Call2&#34; | &#34;Call3&#34; | &#34;Call4&#34;:
                        nargs = int(op.op[4:])
                        args = [f&#34;r{df[f&#39;arg{i}&#39;]}&#34; for i in range(nargs)]
                        if nargs == 0:
                            rhs = f&#34;f${df[&#39;fun&#39;]}()&#34;
                        else:
                            rhs = f&#34;f${df[&#39;fun&#39;]}({&#39;, &#39;.join(args)})&#34;
                    case &#34;CallN&#34;:
                        args = [f&#34;r{arg}&#34; for arg in df[&#34;args&#34;].value]
                        rhs = f&#34;f${df[&#39;fun&#39;]}({&#39;, &#39;.join(args)})&#34;
                    case &#34;CallMethod&#34; | &#34;CallThis&#34;:
                        if op.op == &#34;CallThis&#34;:
                            obj_reg = 0
                            arg_regs = df[&#34;args&#34;].value
                        else:
                            obj_reg = df[&#34;args&#34;].value[0].value
                            arg_regs = df[&#34;args&#34;].value[1:]
                        obj_t = function.regs[obj_reg].resolve(code).definition
                        if isinstance(obj_t, (Obj, Struct)):
                            obj = f&#34;r{obj_reg}&#34;
                            fid = df[&#34;field&#34;].value
                            func_ptr = f&#34;{obj}-&gt;$type-&gt;vobj_proto[{fid}]&#34;
                            dst_reg = df[&#34;dst&#34;].value
                            ret_type = function.regs[dst_reg]
                            obj_type = function.regs[obj_reg]
                            arg_types = [obj_type] + [function.regs[r.value] for r in arg_regs]
                            casted_fun = cast_fun(code, func_ptr, ret_type, arg_types)
                            call_args_str = &#34;, &#34;.join([obj] + [f&#34;r{r.value}&#34; for r in arg_regs])
                            rhs = f&#34;{casted_fun}({call_args_str})&#34;
                        elif isinstance(obj_t, Virtual):
                            raise NotImplementedError(
                                f&#34;CallMethod/CallThis on Virtual type not implemented at op {i} in function {function.findex}&#34;
                            )
                        else:
                            raise MalformedBytecode(
                                f&#34;CallMethod/CallThis on non-Obj/Struct type: {obj_t} at op {i} in function {function.findex}&#34;
                            )
                    case &#34;CallClosure&#34;:
                        closure_reg = df[&#34;fun&#34;]
                        closure_reg_str = regstr(closure_reg)
                        closure_type = function.regs[closure_reg.value].resolve(code)
                        if closure_type.kind.value == Type.Kind.DYN.value:
                            unknown_ops.add(&#34;CallClosure_Dynamic&#34;)
                            opline(i, f&#34;/* CallClosure on dynamic value r{closure_reg.value} not implemented */&#34;)
                            continue
                        if closure_type.kind.value != Type.Kind.FUN.value:
                            raise MalformedBytecode(f&#34;CallClosure on an unexpected type: {closure_type}&#34;)
                        closure_type_def = closure_type.definition
                        assert isinstance(closure_type_def, Fun)
                        ret_type_idx = closure_type_def.ret
                        closure_arg_type_idxs = closure_type_def.args
                        call_arg_regs = df[&#34;args&#34;].value
                        if len(call_arg_regs) != len(closure_arg_type_idxs):
                            raise MalformedBytecode(
                                f&#34;CallClosure argument count mismatch at op {i} in f{function.findex.value}. Expected {len(closure_arg_type_idxs)}, got {len(call_arg_regs)}&#34;
                            )
                        casted_args_str_list = [
                            rcast(code, reg, target_type_idx, function)
                            for reg, target_type_idx in zip(call_arg_regs, closure_arg_type_idxs)
                        ]
                        static_fun_ptr = cast_fun(code, f&#34;{closure_reg_str}-&gt;fun&#34;, ret_type_idx, closure_arg_type_idxs)
                        static_call = f&#34;{static_fun_ptr}({&#39;, &#39;.join(casted_args_str_list)})&#34;
                        dyn_type_idx = code.find_prim_type(Type.Kind.DYN)
                        instance_arg_types = [dyn_type_idx] + closure_arg_type_idxs
                        instance_fun_ptr = cast_fun(code, f&#34;{closure_reg_str}-&gt;fun&#34;, ret_type_idx, instance_arg_types)
                        instance_call = f&#34;{instance_fun_ptr}({&#39;, &#39;.join([f&#39;(vdynamic*){closure_reg_str}-&gt;value&#39;] + casted_args_str_list)})&#34;
                        rhs = f&#34;({closure_reg_str}-&gt;hasValue ? {instance_call} : {static_call})&#34;
                    case &#34;StaticClosure&#34;:
                        rhs = f&#34;&amp;cl${closure_id}&#34;
                        target_fun = df[&#34;fun&#34;].resolve(code)
                        assert isinstance(target_fun, (Function, Native))
                        typ = target_fun.type.resolve(code)
                        assert isinstance(typ.definition, Fun), (
                            f&#34;Expected function type to be Fun, got {type(typ.definition).__name__}. This should never happen.&#34;
                        )
                        res.insert(
                            fn_start,
                            f&#34;    static vclosure cl${closure_id} = {{ &amp;t${target_fun.type}, f${target_fun.findex}, 0 }};&#34;,
                        )
                        closure_id += 1
                    case &#34;InstanceClosure&#34;:
                        target_fun = df[&#34;fun&#34;].resolve(code)
                        assert isinstance(target_fun, (Function, Native))
                        typ = target_fun.type.resolve(code)
                        assert isinstance(typ.definition, Fun), (
                            f&#34;Expected function type to be Fun, got {type(typ.definition).__name__}. This should never happen.&#34;
                        )
                        rhs = f&#34;hl_alloc_closure_ptr(&amp;t${target_fun.type.value}, f${target_fun.findex.value}, r{df[&#39;obj&#39;]})&#34;
                    case &#34;VirtualClosure&#34;:
                        obj_t = function.regs[df[&#34;obj&#34;].value].resolve(code)
                        assert isinstance(obj_t, Type)
                        objdef = obj_t.definition
                        assert isinstance(objdef, (Obj, Struct)), (
                            f&#34;VirtualClosure on non-Obj/Struct type: {objdef} at op {i} in function {function.findex}&#34;
                        )
                        fid = df[&#34;field&#34;].value
                        func_ptr = f&#34;r{df[&#39;obj&#39;]}-&gt;$type-&gt;vobj_proto[{fid}]&#34;
                        fun_t = objdef.virtuals[fid]
                        rhs = f&#34;hl_alloc_closure_ptr(&amp;t${fun_t}, {func_ptr}, r{df[&#39;obj&#39;]})&#34;
                    case &#34;GetGlobal&#34;:
                        dst_reg = df[&#34;dst&#34;].value
                        dst = ctype(code, function.regs[dst_reg].resolve(code), function.regs[dst_reg])
                        rhs = f&#34;({dst})g${df[&#39;global&#39;].value}&#34;
                    case &#34;SetGlobal&#34;:
                        src_reg = df[&#34;src&#34;].value
                        has_dst = False
                        rhs = f&#34;g${df[&#39;global&#39;].value} = r{src_reg}&#34;
                    case &#34;Ret&#34;:
                        has_dst = False
                        if fun.ret.resolve(code).kind.value == Type.Kind.VOID.value:
                            rhs = &#34;return /* void */&#34;
                        else:
                            dst_reg = df[&#34;ret&#34;].value
                            rhs = f&#34;return r{dst_reg}&#34;
                    case &#34;JTrue&#34;:
                        has_dst, no_semi = False, True
                        rhs = f&#34;if (r{df[&#39;cond&#39;]}) goto Op_{df[&#39;offset&#39;].value + i + 1};&#34;
                    case &#34;JFalse&#34;:
                        has_dst, no_semi = False, True
                        rhs = f&#34;if (!r{df[&#39;cond&#39;]}) goto Op_{df[&#39;offset&#39;].value + i + 1};&#34;
                    case &#34;JNull&#34;:
                        has_dst, no_semi = False, True
                        rhs = f&#34;if (!r{df[&#39;reg&#39;]}) goto Op_{df[&#39;offset&#39;].value + i + 1};&#34;
                    case &#34;JNotNull&#34;:
                        has_dst, no_semi = False, True
                        rhs = f&#34;if (r{df[&#39;reg&#39;]}) goto Op_{df[&#39;offset&#39;].value + i + 1};&#34;
                    case &#34;JSLt&#34; | &#34;JSGte&#34; | &#34;JSGt&#34; | &#34;JSLte&#34; | &#34;JEq&#34; | &#34;JNotEq&#34;:
                        has_dst, no_semi, rhs = compare_op(op.op, df, function, code, i)
                    case &#34;JULt&#34;:
                        has_dst, no_semi = False, True
                        rhs = f&#34;if( ((unsigned)r{df[&#39;a&#39;]}) &lt; ((unsigned)r{df[&#39;b&#39;]}) ) goto Op_{df[&#39;offset&#39;].value + i + 1};&#34;
                    case &#34;JUGte&#34;:
                        has_dst, no_semi = False, True
                        rhs = f&#34;if( ((unsigned)r{df[&#39;a&#39;]}) &gt;= ((unsigned)r{df[&#39;b&#39;]}) ) goto Op_{df[&#39;offset&#39;].value + i + 1};&#34;
                    case &#34;JAlways&#34;:
                        has_dst, no_semi = False, True
                        rhs = f&#34;goto Op_{df[&#39;offset&#39;].value + i + 1};&#34;
                    case &#34;Label&#34; | &#34;Nop&#34;:
                        has_dst = False
                        rhs = &#34;dummycall_label();&#34;
                    case &#34;ToDyn&#34;:
                        if function.regs[df[&#34;src&#34;].value].resolve(code).kind.value == Type.Kind.BOOL.value:
                            rhs = f&#34;hl_alloc_dynbool(r{df[&#39;src&#39;]})&#34;
                        else:
                            has_dst, no_semi = False, True
                            typ = function.regs[df[&#34;src&#34;].value].resolve(code)
                            rhs = f&#34;r{df[&#39;dst&#39;]} = hl_alloc_dynamic(&amp;t${function.regs[df[&#39;src&#39;].value]}); &#34;
                            match typ.kind.value:
                                case (
                                    Type.Kind.U8.value
                                    | Type.Kind.U16.value
                                    | Type.Kind.I32.value
                                    | Type.Kind.BOOL.value
                                ):
                                    rhs += f&#34;r{df[&#39;dst&#39;]}-&gt;v.i = r{df[&#39;src&#39;]};&#34;
                                case Type.Kind.I64.value:
                                    rhs += f&#34;r{df[&#39;dst&#39;]}-&gt;v.i64 = r{df[&#39;src&#39;]};&#34;
                                case Type.Kind.F32.value:
                                    rhs += f&#34;r{df[&#39;dst&#39;]}-&gt;v.f = r{df[&#39;src&#39;]};&#34;
                                case Type.Kind.F64.value:
                                    rhs += f&#34;r{df[&#39;dst&#39;]}-&gt;v.d = r{df[&#39;src&#39;]};&#34;
                                case _:
                                    rhs += f&#34;r{df[&#39;dst&#39;]}-&gt;v.ptr = r{df[&#39;src&#39;]};&#34;
                            if is_ptr(typ.kind.value):
                                rhs = f&#34;if( r{df[&#39;src&#39;]} == NULL ) r{df[&#39;dst&#39;]} = NULL; else {{{rhs}}}&#34;
                    case &#34;ToSFloat&#34;:
                        has_dst = False
                        typ = function.regs[df[&#34;dst&#34;].value].resolve(code)
                        rhs = f&#34;r{df[&#39;dst&#39;]} = ({ctype(code, typ, function.regs[df[&#39;dst&#39;].value].value)})r{df[&#39;src&#39;]}&#34;
                    case &#34;ToUFloat&#34;:
                        has_dst = False
                        typ = function.regs[df[&#34;dst&#34;].value].resolve(code)
                        rhs = f&#34;r{df[&#39;dst&#39;]} = ({ctype(code, typ, function.regs[df[&#39;dst&#39;].value].value)})(unsigned)r{df[&#39;src&#39;]}&#34;
                    case &#34;ToInt&#34;:
                        rhs = f&#34;(int)r{df[&#39;src&#39;]}&#34;
                    case &#34;New&#34;:
                        dst_reg = df[&#34;dst&#34;].value
                        dst_t = function.regs[dst_reg]
                        dst_type = dst_t.resolve(code)
                        match dst_type.kind.value:
                            case Type.Kind.OBJ.value | Type.Kind.STRUCT.value:
                                tname = ctype(code, dst_type, dst_t.value)
                                rhs = f&#34;({tname})hl_alloc_obj(&amp;t${dst_t.value})&#34;
                            case Type.Kind.DYNOBJ.value:
                                rhs = &#34;hl_alloc_dynobj()&#34;
                            case Type.Kind.VIRTUAL.value:
                                rhs = f&#34;hl_alloc_virtual(&amp;t${dst_t.value})&#34;
                    case &#34;Field&#34; | &#34;GetThis&#34;:
                        if op.op == &#34;Field&#34;:
                            obj_reg = df[&#34;obj&#34;].value
                        else:
                            obj_reg = 0
                        obj_tres = function.regs[obj_reg].resolve(code)
                        assert isinstance(obj_tres, Type), (
                            f&#34;Expected obj type to be Type, got {type(obj_tres).__name__}. This should never happen.&#34;
                        )
                        field_idx: int = df[&#34;field&#34;].value
                        match obj_tres.kind.value:
                            case Type.Kind.OBJ.value | Type.Kind.STRUCT.value:
                                dfn = obj_tres.definition
                                assert isinstance(dfn, (Obj, Struct)), (
                                    f&#34;Expected obj type definition to be Obj or Struct, got {type(dfn).__name__}. This should never happen.&#34;
                                )
                                field_name = dfn.resolve_fields(code)[field_idx].name.resolve(code)
                                rhs = f&#34;r{obj_reg}-&gt;{sanitize_ident(field_name)}&#34;
                            case Type.Kind.VIRTUAL.value:
                                dfn = obj_tres.definition
                                assert isinstance(dfn, Virtual), &#34;This check should pass.&#34;
                                field_info = dfn.fields[field_idx]
                                field_name = field_info.name.resolve(code)
                                field_hash = hl_hash_utf8(field_name)
                                field_type_idx = field_info.type
                                field_type = field_type_idx.resolve(code)
                                field_ctype = ctype(code, field_type, field_type_idx.value)

                                prefix = dyn_prefix(field_type)
                                type_arg = &#34;&#34;
                                if field_type.kind.value not in {
                                    Type.Kind.F32.value,
                                    Type.Kind.F64.value,
                                    Type.Kind.I64.value,
                                }:
                                    type_arg = f&#34;, &amp;t${field_type_idx.value}&#34;

                                dyn_get_call = f&#34;(({field_ctype})hl_dyn_get{prefix}(r{obj_reg}-&gt;value, {field_hash}/*{field_name}*/{type_arg}))&#34;

                                direct_access = f&#34;(*(({field_ctype}*)hl_vfields({obj_reg})[{field_idx}]))&#34;

                                rhs = f&#34;(hl_vfields({obj_reg})[{field_idx}] ? {direct_access} : {dyn_get_call})&#34;
                    case &#34;SetField&#34; | &#34;SetThis&#34;:
                        if op.op == &#34;SetField&#34;:
                            obj_reg_idx = df[&#34;obj&#34;].value
                            val_reg_idx = df[&#34;src&#34;].value
                        else:
                            obj_reg_idx = 0
                            val_reg_idx = df[&#34;src&#34;].value

                        obj_regs = f&#34;r{obj_reg_idx}&#34;
                        val_regs = f&#34;r{val_reg_idx}&#34;
                        obj_tres = function.regs[obj_reg_idx].resolve(code)
                        field_idx = df[&#34;field&#34;].value
                        has_dst = False

                        assert obj_tres is not None
                        match obj_tres.kind.value:
                            case Type.Kind.OBJ.value | Type.Kind.STRUCT.value:
                                dfn = obj_tres.definition
                                assert isinstance(dfn, (Obj, Struct)), &#34;This check should pass.&#34;

                                field = dfn.resolve_fields(code)[field_idx]
                                field_name = sanitize_ident(field.name.resolve(code))
                                field_type_idx = field.type
                                val_cast = rcast(code, Reg(val_reg_idx), field_type_idx, function)

                                rhs = f&#34;{obj_regs}-&gt;{field_name} = {val_cast}&#34;

                            case Type.Kind.VIRTUAL.value:
                                dfn = obj_tres.definition
                                assert isinstance(dfn, Virtual), &#34;This check should pass.&#34;

                                field_info = dfn.fields[field_idx]
                                field_name = field_info.name.resolve(code)
                                field_hash = hl_hash_utf8(field_name)
                                field_type_idx = field_info.type
                                field_type = field_type_idx.resolve(code)
                                field_ctype = ctype(code, field_type, field_type_idx.value)

                                value_type = function.regs[val_reg_idx].resolve(code)

                                prefix = dyn_prefix(value_type)
                                type_arg = &#34;&#34;
                                if value_type.kind.value not in {
                                    Type.Kind.F32.value,
                                    Type.Kind.F64.value,
                                    Type.Kind.I64.value,
                                }:
                                    type_arg = f&#34;, &amp;t${function.regs[val_reg_idx].value}&#34;

                                dyn_set_call = f&#34;hl_dyn_set{prefix}({obj_regs}-&gt;value, {field_hash}/*{field_name}*/{type_arg}, {val_regs})&#34;
                                val_cast = f&#34;({field_ctype}){val_regs}&#34;
                                direct_set = f&#34;*({field_ctype}*)(hl_vfields({obj_regs})[{field_idx}]) = {val_cast}&#34;
                                rhs = f&#34;if (hl_vfields({obj_regs})[{field_idx}]) {direct_set}; else {dyn_set_call}&#34;
                            case _:
                                unknown_ops.add(f&#34;SetField on {obj_tres.kind}&#34;)
                                continue
                    case &#34;Throw&#34; | &#34;Rethrow&#34;:
                        # Opcodes: Throw: {&#34;exc&#34;: Reg}, Rethrow: {&#34;exc&#34;: Reg}
                        rhs = f&#34;hl_{op.op.lower()}((vdynamic*)r{df[&#39;exc&#39;].value})&#34;
                        has_dst = False
                    case &#34;GetUI8&#34; | &#34;GetI8&#34;:
                        # Opcode: GetI8: {&#34;dst&#34;: Reg, &#34;bytes&#34;: Reg, &#34;index&#34;: Reg}
                        rhs = f&#34;*(unsigned char*)(r{df[&#39;bytes&#39;].value} + r{df[&#39;index&#39;].value})&#34;
                    case &#34;GetUI16&#34; | &#34;GetI16&#34;:
                        # Opcode: GetI16: {&#34;dst&#34;: Reg, &#34;bytes&#34;: Reg, &#34;index&#34;: Reg}
                        rhs = f&#34;*(unsigned short*)(r{df[&#39;bytes&#39;].value} + r{df[&#39;index&#39;].value})&#34;
                    case &#34;GetMem&#34;:
                        # Opcode: GetMem: {&#34;dst&#34;: Reg, &#34;bytes&#34;: Reg, &#34;index&#34;: Reg}
                        dst_type_idx = function.regs[df[&#34;dst&#34;].value]
                        dst_ctype = ctype(code, dst_type_idx.resolve(code), dst_type_idx.value)
                        rhs = f&#34;*({dst_ctype}*)(r{df[&#39;bytes&#39;].value} + r{df[&#39;index&#39;].value})&#34;
                    case &#34;GetArray&#34;:
                        # Opcode: GetArray: {&#34;dst&#34;: Reg, &#34;array&#34;: Reg, &#34;index&#34;: Reg}
                        arr_type = function.regs[df[&#34;array&#34;].value].resolve(code)
                        dst_type_idx = function.regs[df[&#34;dst&#34;].value]
                        dst_ctype = ctype(code, dst_type_idx.resolve(code), dst_type_idx.value)

                        if isinstance(arr_type.definition, Abstract):  # Raw pointer array (e.g. haxe.io.Bytes)
                            rhs = f&#34;(({dst_ctype}*)r{df[&#39;array&#39;].value})[r{df[&#39;index&#39;].value}]&#34;
                        else:  # Standard `varray` with a header
                            rhs = f&#34;(({dst_ctype}*)(r{df[&#39;array&#39;].value} + 1))[r{df[&#39;index&#39;].value}]&#34;
                    case &#34;SetUI8&#34; | &#34;SetI8&#34;:
                        # Opcode: SetI8: {&#34;bytes&#34;: Reg, &#34;index&#34;: Reg, &#34;src&#34;: Reg}
                        rhs = f&#34;*(unsigned char*)(r{df[&#39;bytes&#39;].value} + r{df[&#39;index&#39;].value}) = (unsigned char)r{df[&#39;src&#39;].value}&#34;
                        has_dst = False
                    case &#34;SetUI16&#34; | &#34;SetI16&#34;:
                        # Opcode: SetI16: {&#34;bytes&#34;: Reg, &#34;index&#34;: Reg, &#34;src&#34;: Reg}
                        rhs = f&#34;*(unsigned short*)(r{df[&#39;bytes&#39;].value} + r{df[&#39;index&#39;].value}) = (unsigned short)r{df[&#39;src&#39;].value}&#34;
                        has_dst = False
                    case &#34;SetMem&#34;:
                        # Opcode: SetMem: {&#34;bytes&#34;: Reg, &#34;index&#34;: Reg, &#34;src&#34;: Reg}
                        val_type_idx = function.regs[df[&#34;src&#34;].value]
                        val_ctype = ctype(code, val_type_idx.resolve(code), val_type_idx.value)
                        rhs = f&#34;*({val_ctype}*)(r{df[&#39;bytes&#39;].value} + r{df[&#39;index&#39;].value}) = r{df[&#39;src&#39;].value}&#34;
                        has_dst = False
                    case &#34;SetArray&#34;:
                        # Opcode: SetArray: {&#34;array&#34;: Reg, &#34;index&#34;: Reg, &#34;src&#34;: Reg}
                        arr_type = function.regs[df[&#34;array&#34;].value].resolve(code)
                        val_type_idx = function.regs[df[&#34;src&#34;].value]
                        val_ctype = ctype(code, val_type_idx.resolve(code), val_type_idx.value)

                        if isinstance(arr_type.definition, Abstract):
                            rhs = f&#34;(({val_ctype}*)r{df[&#39;array&#39;].value})[r{df[&#39;index&#39;].value}] = r{df[&#39;src&#39;].value}&#34;
                        else:
                            rhs = (
                                f&#34;(({val_ctype}*)(r{df[&#39;array&#39;].value} + 1))[r{df[&#39;index&#39;].value}] = r{df[&#39;src&#39;].value}&#34;
                            )
                        has_dst = False
                    case &#34;SafeCast&#34;:
                        # Opcode: SafeCast: {&#34;dst&#34;: Reg, &#34;src&#34;: Reg}
                        src_reg, dst_reg = df[&#34;src&#34;].value, df[&#34;dst&#34;].value
                        src_type = function.regs[src_reg].resolve(code)
                        dst_type_idx = function.regs[dst_reg]
                        dst_type = dst_type_idx.resolve(code)
                        dst_ctype = ctype(code, dst_type, dst_type_idx.value)

                        if isinstance(src_type.definition, Null):
                            assert isinstance(src_type.definition.type, tIndex)
                            rhs = f&#34;r{src_reg} ? r{src_reg}-&gt;v.{dyn_value_field(src_type.definition.type.resolve(code))} : 0&#34;
                        else:
                            prefix = dyn_prefix(dst_type)
                            type_arg = &#34;&#34;
                            if dst_type.kind.value not in {
                                Type.Kind.F32.value,
                                Type.Kind.F64.value,
                                Type.Kind.I64.value,
                            }:
                                type_arg = f&#34;, &amp;t${dst_type_idx.value}&#34;

                            src_type_idx = function.regs[src_reg].value
                            rhs = f&#34;({dst_ctype})hl_dyn_cast{prefix}(&amp;r{src_reg}, &amp;t${src_type_idx}{type_arg})&#34;
                    case &#34;UnsafeCast&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;src&#34;: Reg}
                        # OCaml: sexpr &#34;%s = (%s)%s&#34; (reg r) (ctype (rtype r)) (reg v)
                        dst_type_idx = function.regs[df[&#34;dst&#34;].value]
                        dst_ctype = ctype(code, dst_type_idx.resolve(code), dst_type_idx.value)
                        rhs = f&#34;({dst_ctype})r{df[&#39;src&#39;].value}&#34;
                    case &#34;ToVirtual&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;src&#34;: &#34;Reg&#34;}
                        # OCaml: sexpr &#34;%s = hl_to_virtual(%s,(vdynamic*)%s)&#34; (reg r) (type_value ctx (rtype r)) (reg v)
                        dst_type_idx = function.regs[df[&#34;dst&#34;].value]
                        rhs = f&#34;hl_to_virtual(&amp;t${dst_type_idx.value}, (vdynamic*)r{df[&#39;src&#39;].value})&#34;
                    case &#34;ArraySize&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;array&#34;: Reg}
                        # OCaml: sexpr &#34;%s = %s-&gt;size&#34; (reg r) (reg a)
                        rhs = f&#34;r{df[&#39;array&#39;].value}-&gt;size&#34;
                    case &#34;Type&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;ty&#34;: RefType}
                        # OCaml: sexpr &#34;%s = %s&#34; (reg r) (type_value ctx t)
                        rhs = f&#34;&amp;t${df[&#39;ty&#39;].value}&#34;
                    case &#34;GetType&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;src&#34;: Reg}
                        # OCaml: sexpr &#34;%s = %s ? ((vdynamic*)%s)-&gt;t : &amp;hlt_void&#34; (reg r) (reg v) (reg v)
                        rhs = f&#34;r{df[&#39;src&#39;].value} ? ((vdynamic*)r{df[&#39;src&#39;].value})-&gt;t : &amp;hlt_void&#34;
                    case &#34;GetTID&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;src&#34;: Reg}
                        # OCaml: sexpr &#34;%s = %s-&gt;kind&#34; (reg r) (reg v)
                        rhs = f&#34;r{df[&#39;src&#39;].value}-&gt;kind&#34;
                    case &#34;DynGet&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;obj&#34;: Reg, &#34;field&#34;: RefString}
                        # OCaml: sexpr &#34;%s = (%s)hl_dyn_get%s((vdynamic*)%s,%ld/*%s*/%s)&#34; (reg r) (ctype t) (dyn_prefix t) (reg o) h code.strings.(sid) (type_value_opt t)
                        dst_type_idx = function.regs[df[&#34;dst&#34;].value]
                        dst_type = dst_type_idx.resolve(code)
                        dst_ctype = ctype(code, dst_type, dst_type_idx.value)

                        field_name = df[&#34;field&#34;].resolve(code)
                        field_hash = hl_hash_utf8(field_name)
                        prefix = dyn_prefix(dst_type)

                        type_arg = &#34;&#34;
                        if dst_type.kind.value not in {Type.Kind.F32.value, Type.Kind.F64.value, Type.Kind.I64.value}:
                            type_arg = f&#34;, &amp;t${dst_type_idx.value}&#34;

                        rhs = f&#34;({dst_ctype})hl_dyn_get{prefix}((vdynamic*)r{df[&#39;obj&#39;].value}, {field_hash}/*{field_name}*/{type_arg})&#34;
                    case &#34;DynSet&#34;:
                        # Opcode: {&#34;obj&#34;: Reg, &#34;field&#34;: RefString, &#34;src&#34;: Reg}
                        # OCaml: sexpr &#34;hl_dyn_set%s((vdynamic*)%s,%ld/*%s*/%s,%s)&#34; (dyn_prefix (rtype v)) (reg o) h code.strings.(sid) (type_value_opt (rtype v)) (reg v)
                        has_dst = False
                        src_reg = df[&#34;src&#34;].value
                        src_type_idx = function.regs[src_reg]
                        src_type = src_type_idx.resolve(code)

                        field_name = df[&#34;field&#34;].resolve(code)
                        field_hash = hl_hash_utf8(field_name)
                        prefix = dyn_prefix(src_type)

                        type_arg = &#34;&#34;
                        if src_type.kind.value not in {Type.Kind.F32.value, Type.Kind.F64.value, Type.Kind.I64.value}:
                            type_arg = f&#34;, &amp;t${src_type_idx.value}&#34;

                        rhs = f&#34;hl_dyn_set{prefix}((vdynamic*)r{df[&#39;obj&#39;].value}, {field_hash}/*{field_name}*/{type_arg}, r{src_reg})&#34;
                    case &#34;MakeEnum&#34;:
                        has_dst, no_semi = False, True

                        dst_reg_idx = df[&#34;dst&#34;].value
                        cid = df[&#34;construct&#34;].value
                        arg_regs = df[&#34;args&#34;].value
                        param_reg_indices = [r.value for r in arg_regs]
                        need_tmp = dst_reg_idx in param_reg_indices

                        enum_def = function.regs[dst_reg_idx].resolve(code).definition
                        assert isinstance(enum_def, Enum)

                        line(f&#34;Op_{i}:&#34;)

                        with indent:
                            if need_tmp:
                                line(&#34;{&#34;)
                                with indent:
                                    line(&#34;venum *tmp;&#34;)
                                    target_var = &#34;tmp&#34;

                                    dst_type_tindex = function.regs[dst_reg_idx].value
                                    line(f&#34;{target_var} = hl_alloc_enum(&amp;t{dst_type_tindex}, {cid});&#34;)

                                    constr_ctype = enum_constr_type(code, enum_def, cid)
                                    param_types = enum_def.constructs[cid].params
                                    for idx, param_reg in enumerate(arg_regs):
                                        param_type_idx = param_types[idx]
                                        val_cast = rcast(code, param_reg, param_type_idx, function)
                                        line(f&#34;(({constr_ctype}*){target_var})-&gt;p{idx} = {val_cast};&#34;)

                                    line(f&#34;r{dst_reg_idx} = {target_var};&#34;)
                                line(&#34;}&#34;)
                            else:
                                target_var = f&#34;r{dst_reg_idx}&#34;
                                dst_type_tindex = function.regs[dst_reg_idx].value
                                line(f&#34;{target_var} = hl_alloc_enum(&amp;t{dst_type_tindex}, {cid});&#34;)

                                constr_ctype = enum_constr_type(code, enum_def, cid)
                                param_types = enum_def.constructs[cid].params
                                for idx, param_reg in enumerate(arg_regs):
                                    param_type_idx = param_types[idx]
                                    val_cast = rcast(code, param_reg, param_type_idx, function)
                                    line(f&#34;(({constr_ctype}*){target_var})-&gt;p{idx} = {val_cast};&#34;)
                        continue
                    case &#34;EnumAlloc&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;construct&#34;: RefEnumConstruct}
                        # OCaml: sexpr &#34;%s = hl_alloc_enum(%s,%d)&#34; (reg r) (type_value ctx (rtype r)) cid
                        dst_type_idx = function.regs[df[&#34;dst&#34;].value]
                        cid = df[&#34;construct&#34;].value
                        rhs = f&#34;hl_alloc_enum(&amp;t{dst_type_idx.value}, {cid})&#34;
                    case &#34;EnumIndex&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;value&#34;: Reg}
                        # OCaml: sexpr &#34;%s = HL__ENUM_INDEX__(%s)&#34; (reg r) (reg v)
                        rhs = f&#34;HL__ENUM_INDEX__(r{df[&#39;value&#39;].value})&#34;
                    case &#34;EnumField&#34;:
                        # Opcode: {&#34;dst&#34;: Reg, &#34;value&#34;: Reg, &#34;construct&#34;: RefEnumConstruct, &#34;field&#34;: RefField}
                        # OCaml: sexpr &#34;%s((%s*)%s)-&gt;p%d&#34; (rassign r tl.(pid)) tname (reg e) pid
                        dst_reg_idx = df[&#34;dst&#34;].value
                        enum_reg_idx = df[&#34;value&#34;].value
                        cid = df[&#34;construct&#34;].value
                        pid = df[&#34;field&#34;].value
                        enum_type = function.regs[enum_reg_idx].resolve(code)
                        enum_def = enum_type.definition
                        assert isinstance(enum_def, Enum), &#34;EnumField source must be an Enum type.&#34;
                        constr_ctype = enum_constr_type(code, enum_def, cid)
                        param_types = enum_def.constructs[cid].params
                        field_type_idx = param_types[pid]

                        rhs = f&#34;(({constr_ctype}*)r{enum_reg_idx})-&gt;p{pid}&#34;
                        dst_type = function.regs[dst_reg_idx]
                        if field_type_idx.value != dst_type.value:
                            rhs = f&#34;({ctype(code, dst_type.resolve(code), dst_type.value)})({rhs})&#34;
                    case &#34;SetEnumField&#34;:
                        # Opcode: {&#34;value&#34;: Reg, &#34;field&#34;: RefField, &#34;src&#34;: Reg}
                        # OCaml: sexpr &#34;((%s*)%s)-&gt;p%d = (%s)%s&#34; tname (reg e) pid (ctype tl.(pid)) (reg r)
                        has_dst = False
                        enum_reg_idx = df[&#34;value&#34;].value
                        pid = df[&#34;field&#34;].value
                        src_reg_idx = df[&#34;src&#34;].value

                        enum_type = function.regs[enum_reg_idx].resolve(code)
                        enum_def = enum_type.definition
                        assert isinstance(enum_def, Enum), &#34;SetEnumField target must be an Enum type.&#34;
                        cid_for_type = -1
                        for i, constr in enumerate(enum_def.constructs):
                            if constr.params:
                                cid_for_type = i
                                break
                        if cid_for_type == -1:
                            raise MalformedBytecode(f&#34;SetEnumField used on an enum with no parameters at op {i}&#34;)

                        constr_ctype = enum_constr_type(code, enum_def, cid_for_type)
                        field_type_idx = enum_def.constructs[cid_for_type].params[pid]

                        val_cast = rcast(code, Reg(src_reg_idx), field_type_idx, function)
                        rhs = f&#34;(({constr_ctype}*)r{enum_reg_idx})-&gt;p{pid} = {val_cast}&#34;
                    case &#34;Switch&#34;:
                        has_dst, no_semi = False, True

                        reg_to_switch = df[&#34;reg&#34;].value
                        offsets = df[&#34;offsets&#34;].value
                        end_offset = df[&#34;end&#34;].value
                        line(f&#34;Op_{i}:&#34;)
                        with indent:
                            for case_idx, offset_varint in enumerate(offsets):
                                target_op_idx = i + 1 + offset_varint.value
                                line(f&#34;if (r{reg_to_switch} == {case_idx}) goto Op_{target_op_idx};&#34;)

                            default_target_op_idx = i + 1
                            line(f&#34;goto Op_{default_target_op_idx}; // default&#34;)
                        continue
                    case &#34;NullCheck&#34;:
                        has_dst = False
                        rhs = f&#34;if( r{df[&#39;reg&#39;]} == NULL ) hl_null_access()&#34;
                    case &#34;Trap&#34;:
                        opline(i, f&#34;hl_trap(trap${trap_depth}, {regstr(df[&#39;exc&#39;])}, Op_{i + 1 + df[&#39;offset&#39;].value});&#34;)
                        trap_depth += 1
                        continue
                    case &#34;EndTrap&#34;:
                        trap_depth -= 1
                        opline(i, f&#34;hl_endtrap(&amp;trap${trap_depth});&#34;)
                        continue
                    case &#34;Assert&#34;:
                        has_dst = False
                        rhs = &#34;hl_assert()&#34;
                    case &#34;Ref&#34;:
                        rhs = f&#34;&amp;r{df[&#39;src&#39;]}&#34;
                    case &#34;Unref&#34;:
                        rhs = f&#34;*r{df[&#39;src&#39;]}&#34;
                    case &#34;Setref&#34;:
                        has_dst = False
                        rhs = r&#34;*r{df[&#39;dst&#39;]} = r{df[&#39;value&#39;]}&#34;
                    case &#34;RefData&#34;:
                        dst_reg = df[&#34;dst&#34;].value
                        src_reg = df[&#34;src&#34;].value
                        src_type = function.regs[src_reg.value].resolve(code)

                        if isinstance(src_type.definition, Array):
                            dst_type_idx = function.regs[dst_reg.value]
                            dst_ctype = ctype(code, dst_type_idx.resolve(code), dst_type_idx.value)
                            rhs = f&#34;({dst_ctype})hl_aptr({regstr(src_reg)}, void*)&#34;
                        else:
                            raise MalformedBytecode(
                                f&#34;RefData at op {i} in function {function.findex} expects an Array type in source register, but got {src_type.definition.__class__.__name__}&#34;
                            )
                    case &#34;RefOffset&#34;:
                        # Opcode: {&#34;dst&#34;: &#34;Reg&#34;, &#34;reg&#34;: &#34;Reg&#34;, &#34;offset&#34;: &#34;Reg&#34;}
                        rhs = f&#34;r{df[&#39;reg&#39;].value} + r{df[&#39;offset&#39;].value}&#34;
                    case &#34;Prefetch&#34;:
                        has_dst = False

                        obj_r = df[&#34;value&#34;]
                        field_id = df[&#34;field&#34;].value
                        mode = df[&#34;mode&#34;].value

                        if not (0 &lt;= mode &lt;= 3):
                            raise MalformedBytecode(
                                f&#34;Invalid prefetch mode {mode} at op {i} in function {function.findex}&#34;
                            )

                        prefetch_expr = &#34;&#34;
                        if field_id == 0:
                            prefetch_expr = regstr(obj_r)
                        else:
                            obj_typ = function.regs[obj_r.value].resolve(code)
                            obj_def = obj_typ.definition

                            if isinstance(obj_def, (Obj, Struct)):
                                field_index = field_id - 1
                                try:
                                    resolved_fields = obj_def.resolve_fields(code)
                                    field = resolved_fields[field_index]
                                    field_c_name = sanitize_ident(field.name.resolve(code))
                                    prefetch_expr = f&#34;&amp;{regstr(obj_r)}-&gt;{field_c_name}&#34;
                                except IndexError:
                                    raise MalformedBytecode(
                                        f&#34;Prefetch field index {field_id} is out of bounds for object {obj_def.name.resolve(code)} at op {i}&#34;
                                    )
                            else:
                                raise MalformedBytecode(
                                    f&#34;Prefetch with non-zero field_id used on a non-object type ({obj_typ.resolve(code).definition.__class__.__name__}) at op {i}&#34;
                                )

                        rhs = f&#34;__hl_prefetch_m{mode}({prefetch_expr})&#34;
                    case &#34;Asm&#34;:
                        raise MalformedBytecode(
                            &#34;Asm is not supported by either the official HL/C compiler or crashlink. This is done intentionally for feature parity.&#34;
                        )
                    case _:
                        unknown_ops.add(op.op if op.op else &#34;unknown?????&#34;)
                        continue

                if has_dst:
                    dst_type = function.regs[df[&#34;dst&#34;].value].resolve(code)
                    if dst_type.kind.value == Type.Kind.VOID.value:
                        opline(i, f&#34;{rhs}; // void dst&#34;)
                    else:
                        opline(i, f&#34;r{df[&#39;dst&#39;]} = {rhs};&#34;)
                elif no_semi:
                    opline(i, f&#34;{rhs}&#34;)  # no semicolon for some ops
                else:
                    opline(i, f&#34;{rhs};&#34;)
        line(&#34;}&#34;)

    return res</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.hlc.generate_globals"><code class="name flex">
<span>def <span class="ident">generate_globals</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_globals(code: Bytecode) -&gt; List[str]:
    &#34;&#34;&#34;Generates C code for all global variables and their initialization.&#34;&#34;&#34;
    res, indent = [], Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    if not code.global_types:
        return res

    all_types = code.types
    line(&#34;// Global variables&#34;)
    for i, g_type_ptr in enumerate(code.global_types):
        g_type = g_type_ptr.resolve(code)
        c_type_str = ctype(code, g_type, all_types.index(g_type))
        line(f&#34;{c_type_str} g${i} = 0;&#34;)

    for const in tqdm(code.constants, desc=&#34;Generating global constants&#34;) if USE_TQDM else code.constants:  # pyright: ignore[reportPossiblyUnboundVariable]
        obj = const._global.resolve(code).definition
        objIdx = const._global.partial_resolve(code).value
        assert isinstance(obj, Obj), (
            f&#34;Expected global constant to be an Obj, got {type(obj).__name__}. This should never happen.&#34;
        )
        fields = obj.resolve_fields(code)
        const_fields: List[str] = []
        for i, field in enumerate(const.fields):
            typd = fields[i].type.resolve(code).definition
            name = fields[i].name.resolve(code)
            if isinstance(typd, (Obj, Struct)):
                raise MalformedBytecode(&#34;Global constants cannot contain other initialized Objs or Structs.&#34;)
            elif isinstance(typd, (I32, U8, U16, I64)):
                const_fields.append(str(code.ints[field.value].value))
            elif isinstance(typd, (F32, F64)):
                const_fields.append(str(code.floats[field.value].value))
            elif isinstance(typd, Bytes):
                val = code.strings.value[field.value]
                c_escaped_str = val.replace(&#34;\\&#34;, &#34;\\\\&#34;).replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;).replace(&#34;\n&#34;, &#34;\\n&#34;).replace(&#34;\r&#34;, &#34;\\r&#34;)
                const_fields.append(f&#39;(vbyte*)USTR(&#34;{c_escaped_str}&#34;)&#39;)
        line(f&#34;static struct _obj${objIdx} const_g${const._global.value} = {{&amp;t${objIdx}, {&#39;, &#39;.join(const_fields)}}};&#34;)

    line(&#34;\n// Type initializer&#34;)
    line(&#34;void hl_init_types( hl_module_context *ctx ) {&#34;)
    with indent:
        for j, typ in enumerate(code.types):
            df = typ.definition
            if isinstance(df, (Obj, Struct)):
                line(f&#34;objt${j}.m = ctx;&#34;)
                if df._global and df._global.value:
                    line(
                        f&#34;objt${j}.global_value = (void**)&amp;g${df._global.value - 1};&#34;
                    )  # I think the 1-index is correct, but I&#39;m still a bit iffy about this. YOLO!
                line(f&#34;t${j}.obj = &amp;objt${j};&#34;)
            elif isinstance(df, Fun):
                line(f&#34;t${j}.fun = &amp;tfunt${j};&#34;)
            elif isinstance(df, Virtual):
                line(f&#34;t${j}.virt = &amp;virtt${j};&#34;)
                line(f&#34;hl_init_virtual(&amp;t${j},ctx);&#34;)
            elif isinstance(df, Enum):
                line(f&#34;t${j}.tenum = &amp;enumt${j};&#34;)
                if df._global and df._global.value:
                    line(f&#34;enumt${j}.global_value = (void**)&amp;g${df._global.value - 1};&#34;)
                line(f&#34;hl_init_enum(&amp;t${j},ctx);&#34;)
            elif isinstance(df, (Null, Ref)):
                line(f&#34;t${j}.tparam = &amp;t${df.type.value};&#34;)
    line(&#34;}\n&#34;)

    line(&#34;\nvoid hl_init_roots() {&#34;)
    with indent:
        for const in tqdm(code.constants, desc=&#34;Initializing global constants&#34;) if USE_TQDM else code.constants:  # pyright: ignore[reportPossiblyUnboundVariable]
            line(f&#34;g${const._global.value} = &amp;const_g${const._global.value};&#34;)
        for i, g_type_ptr in enumerate(code.global_types):
            g_type = g_type_ptr.resolve(code)
            if is_gc_ptr(g_type):
                line(f&#34;hl_add_root((void**)&amp;g${i});&#34;)
    line(&#34;}&#34;)
    return res</code></pre>
</details>
<div class="desc"><p>Generates C code for all global variables and their initialization.</p></div>
</dd>
<dt id="crashlink.hlc.generate_hashes"><code class="name flex">
<span>def <span class="ident">generate_hashes</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_hashes(code: Bytecode) -&gt; List[str]:
    res_h = []
    indent_h = Indenter()

    def line_h(*args: Any) -&gt; None:
        res_h.append(indent_h.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    hashed_strings = set()
    for func in code.functions:
        for op in func.ops:
            if op.op in {&#34;DynGet&#34;, &#34;DynSet&#34;}:
                hashed_strings.add(op.df[&#34;field&#34;].resolve(code))
            elif op.op in {&#34;SetField&#34;, &#34;Field&#34;} and isinstance(
                func.regs[op.df[&#34;obj&#34;].value].resolve(code).definition, Virtual
            ):
                vdef = func.regs[op.df[&#34;obj&#34;].value].resolve(code).definition
                assert isinstance(vdef, Virtual)
                hashed_strings.add(vdef.fields[op.df[&#34;field&#34;].value].name.resolve(code))
    line_h(&#34;void hl_init_hashes() {&#34;)
    with indent_h:
        for s in sorted(list(hashed_strings)):
            c_escaped_str = s.replace(&#34;\\&#34;, &#34;\\\\&#34;).replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;).replace(&#34;\n&#34;, &#34;\\n&#34;).replace(&#34;\r&#34;, &#34;\\r&#34;)
            line_h(f&#39;hl_hash((vbyte*)USTR(&#34;{c_escaped_str}&#34;));&#39;)
    line_h(&#34;}&#34;)
    return res_h</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="crashlink.hlc.generate_natives"><code class="name flex">
<span>def <span class="ident">generate_natives</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_natives(code: Bytecode) -&gt; List[str]:
    &#34;&#34;&#34;Generates forward declarations for abstract types and native function prototypes.&#34;&#34;&#34;
    res = []
    indent = Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    line(&#34;// Abstract type forward declarations&#34;)
    all_types = code.types
    abstract_names = set()
    for typ in all_types:
        if isinstance(typ.definition, Abstract):
            name = typ.definition.name.resolve(code)
            if name not in {&#34;hl_tls&#34;, &#34;hl_mutex&#34;, &#34;hl_thread&#34;}:
                abstract_names.add(sanitize_ident(name))

    for name in sorted(list(abstract_names)):
        line(f&#34;typedef struct _{name} {name};&#34;)

    res.append(&#34;&#34;)

    line(&#34;// Native function prototypes&#34;)
    sorted_natives = sorted(code.natives, key=lambda n: (n.lib.resolve(code), n.name.resolve(code)))

    for native in sorted_natives:
        func_type = native.type.resolve(code)
        if not isinstance(func_type.definition, Fun):
            continue
        fun_def = func_type.definition

        lib_name = native.lib.resolve(code).lstrip(&#34;?&#34;)
        c_func_name = f&#34;{&#39;hl&#39; if lib_name == &#39;std&#39; else lib_name}_{native.name.resolve(code)}&#34;
        ret_type_str = ctype(code, fun_def.ret.resolve(code), fun_def.ret.value)
        arg_types = [ctype(code, arg.resolve(code), arg.value) for arg in fun_def.args]
        args_str = &#34;, &#34;.join(arg_types) if arg_types else &#34;void&#34;

        if c_func_name not in {&#34;hl_tls_set&#34;}:  # filter out built-ins we don&#39;t want to redefine
            line(f&#34;HL_API {ret_type_str} {c_func_name}({args_str});&#34;)
            args_with_names = (
                &#34;, &#34;.join(f&#34;{arg_type} r{i}&#34; for i, arg_type in enumerate(arg_types)) if arg_types else &#34;void&#34;
            )
            line(f&#34;{ret_type_str} f${native.findex.value}({args_with_names}){{&#34;)
            with indent:
                line(f&#34;return {c_func_name}({&#39;, &#39;.join(f&#39;r{i}&#39; for i in range(len(arg_types))) if arg_types else &#39;&#39;});&#34;)
            line(&#34;}&#34;)
    return res</code></pre>
</details>
<div class="desc"><p>Generates forward declarations for abstract types and native function prototypes.</p></div>
</dd>
<dt id="crashlink.hlc.generate_reflection"><code class="name flex">
<span>def <span class="ident">generate_reflection</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_reflection(code: Bytecode) -&gt; List[str]:
    &#34;&#34;&#34;Generates the C reflection helpers: hlc_static_call and the function wrappers.&#34;&#34;&#34;
    res = []
    indent = Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    def get_type_kind(typ: Type) -&gt; Type.Kind:
        &#34;&#34;&#34;Simplifies a type into a broader category for reflection.&#34;&#34;&#34;
        kind_val = typ.kind.value
        if kind_val in {Type.Kind.BOOL.value, Type.Kind.U8.value, Type.Kind.U16.value, Type.Kind.I32.value}:
            return Type.Kind.I32
        if kind_val in {Type.Kind.F32.value, Type.Kind.F64.value, Type.Kind.I64.value, Type.Kind.VOID.value}:
            return Type.Kind(kind_val)
        return Type.Kind.DYN

    def get_type_kind_id(kind: Type.Kind) -&gt; int:
        &#34;&#34;&#34;Maps a kinded type to a small integer for building a unique signature hash.&#34;&#34;&#34;
        kind_map = {
            Type.Kind.VOID.value: 0,
            Type.Kind.I32.value: 1,
            Type.Kind.F32.value: 2,
            Type.Kind.F64.value: 3,
            Type.Kind.I64.value: 4,
            Type.Kind.DYN.value: 5,
        }
        return kind_map.get(kind.value, 5)

    fun_by_args: Dict[int, Dict[Tuple[Tuple[Type.Kind, ...], Type.Kind], None]] = {}

    def add_fun(args: List[Type], ret: Type) -&gt; None:
        nargs = len(args)
        kinded_args = tuple(get_type_kind(arg) for arg in args)
        kinded_ret = get_type_kind(ret)

        if nargs not in fun_by_args:
            fun_by_args[nargs] = {}
        fun_by_args[nargs][(kinded_args, kinded_ret)] = None

    for func in tqdm(code.functions, desc=&#34;Collecting function signatures&#34;) if USE_TQDM else code.functions:  # pyright: ignore[reportPossiblyUnboundVariable]
        for op in func.ops:
            if op.op in {&#34;SafeCast&#34;, &#34;DynGet&#34;}:
                dst_type = func.regs[op.df[&#34;dst&#34;].value].resolve(code)
                if isinstance(dst_type.definition, Fun):
                    fun_def = dst_type.definition
                    arg_types = [t.resolve(code) for t in fun_def.args]
                    ret_type = fun_def.ret.resolve(code)
                    add_fun(arg_types, ret_type)

    f: Function | Native
    for f in code.functions:
        f_def = f.type.resolve(code).definition
        if isinstance(f_def, Fun):
            add_fun([t.resolve(code) for t in f_def.args], f_def.ret.resolve(code))
    for n in code.natives:
        n_def = n.type.resolve(code).definition
        if isinstance(n_def, Fun):
            add_fun([t.resolve(code) for t in n_def.args], n_def.ret.resolve(code))

    line(&#34;static int TKIND[] = {0,1,1,1,4,2,3,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5};&#34;)
    line(&#34;&#34;)
    line(&#34;void *hlc_static_call( void *fun, hl_type *t, void **args, vdynamic *out ) {&#34;)
    with indent:
        line(&#34;int chk = TKIND[t-&gt;fun-&gt;ret-&gt;kind];&#34;)
        line(&#34;vdynamic *d;&#34;)
        line(&#34;switch( t-&gt;fun-&gt;nargs ) {&#34;)

        sorted_arg_counts = sorted(fun_by_args.keys())
        for nargs in tqdm(sorted_arg_counts, desc=&#34;Generating signatures&#34;) if USE_TQDM else sorted_arg_counts:  # pyright: ignore[reportPossiblyUnboundVariable]
            line(f&#34;case {nargs}:&#34;)
            with indent:
                if nargs &gt; 9:
                    line(&#39;hl_fatal(&#34;Too many arguments, TODO:use more bits&#34;);&#39;)
                else:
                    for i in range(nargs):
                        line(f&#34;chk |= TKIND[t-&gt;fun-&gt;args[{i}]-&gt;kind] &lt;&lt; {(i + 1) * 3};&#34;)
                    line(&#34;switch( chk ) {&#34;)

                    signatures = fun_by_args[nargs]
                    for (arg_kinds, ret_kind), _ in signatures.items():
                        all_kinds = [ret_kind] + list(arg_kinds)
                        chk_val = sum(get_type_kind_id(kind) &lt;&lt; (i * 3) for i, kind in enumerate(all_kinds))
                        line(f&#34;case {chk_val}:&#34;)
                        with indent:
                            found_sig = False
                            for f in code.functions + code.natives:
                                f_def = f.type.resolve(code).definition
                                if isinstance(f_def, Fun) and len(f_def.args) == nargs:
                                    current_arg_tindices = f_def.args
                                    current_ret_tindex = f_def.ret
                                    current_arg_types = [t.resolve(code) for t in current_arg_tindices]
                                    current_ret_type = current_ret_tindex.resolve(code)

                                    if (
                                        tuple(get_type_kind(t) for t in current_arg_types) == arg_kinds
                                        and get_type_kind(current_ret_type) == ret_kind
                                    ):
                                        arg_list_str = []
                                        for i, arg_tindex in enumerate(current_arg_tindices):
                                            arg_type = arg_tindex.resolve(code)
                                            if is_ptr(arg_type.kind.value):
                                                arg_list_str.append(
                                                    f&#34;({ctype(code, arg_type, arg_tindex.value)})args[{i}]&#34;
                                                )
                                            else:
                                                arg_list_str.append(
                                                    f&#34;*({ctype(code, arg_type, arg_tindex.value)}*)args[{i}]&#34;
                                                )

                                        call_str = f&#34;{cast_fun(code, &#39;fun&#39;, current_ret_tindex, current_arg_tindices)}({&#39;, &#39;.join(arg_list_str)})&#34;

                                        if is_ptr(current_ret_type.kind.value):
                                            line(f&#34;return {call_str};&#34;)
                                        elif current_ret_type.kind.value == Type.Kind.VOID.value:
                                            line(f&#34;{call_str};&#34;)
                                            line(&#34;return NULL;&#34;)
                                        else:
                                            line(f&#34;out-&gt;v.{dyn_value_field(current_ret_type)} = {call_str};&#34;)
                                            line(f&#34;return &amp;out-&gt;v.{dyn_value_field(current_ret_type)};&#34;)
                                        found_sig = True
                                        break
                            if not found_sig:
                                line(&#34;/* Signature not found for this case, should not happen */&#34;)

                    line(&#34;}&#34;)
                    line(&#34;break;&#34;)
        line(&#34;}&#34;)
        line(&#39;hl_fatal(&#34;Unsupported dynamic call&#34;);&#39;)
        line(&#34;return NULL;&#34;)
    line(&#34;}&#34;)
    line(&#34;&#34;)

    # --- 3. Generate wrapper functions ---
    def get_wrap_char(typ: Type) -&gt; str:
        kind = typ.kind.value
        if kind == Type.Kind.VOID.value:
            return &#34;v&#34;
        if kind in {Type.Kind.U8.value, Type.Kind.U16.value, Type.Kind.I32.value, Type.Kind.BOOL.value}:
            return &#34;i&#34;
        if kind == Type.Kind.F32.value:
            return &#34;f&#34;
        if kind == Type.Kind.F64.value:
            return &#34;d&#34;
        if kind == Type.Kind.I64.value:
            return &#34;i64&#34;
        return &#34;p&#34;

    def make_wrap_name(args: List[Type], ret: Type) -&gt; str:
        return &#34;&#34;.join(get_wrap_char(t) for t in args) + &#34;_&#34; + get_wrap_char(ret)

    for nargs in sorted_arg_counts:
        processed_wrappers = set()
        for f in code.functions + code.natives:
            f_def = f.type.resolve(code).definition
            if isinstance(f_def, Fun) and len(f_def.args) == nargs:
                # --- FIX IS HERE ---
                # We need the original tIndex objects to generate correct C types
                arg_tindices = f_def.args
                ret_tindex = f_def.ret
                arg_types = [t.resolve(code) for t in arg_tindices]
                ret_type = ret_tindex.resolve(code)
                # --- END OF FIX ---

                wrap_name = make_wrap_name(arg_types, ret_type)
                if wrap_name in processed_wrappers:
                    continue
                processed_wrappers.add(wrap_name)

                c_args = [f&#34;p{i}&#34; for i in range(nargs)]
                # --- FIX IS HERE ---
                # Pass the correct index to ctype
                c_args_typed = [
                    f&#34;{ctype(code, t, t_idx.value)} {name}&#34; for t, t_idx, name in zip(arg_types, arg_tindices, c_args)
                ]
                # --- END OF FIX ---
                c_args_str = &#34;, &#34;.join(c_args_typed)

                line(
                    f&#34;static {ctype(code, ret_type, ret_tindex.value)} wrap_{wrap_name}(void *value{&#39;, &#39; + c_args_str if c_args_str else &#39;&#39;}) {{&#34;
                )
                with indent:
                    if arg_types:
                        packed_args = [
                            f&#34;&amp;p{i}&#34; if not is_ptr(t.kind.value) else f&#34;p{i}&#34; for i, t in enumerate(arg_types)
                        ]
                        line(f&#34;void *args[] = {{{&#39;, &#39;.join(packed_args)}}};&#34;)

                    vargs = &#34;args&#34; if arg_types else &#34;NULL&#34;
                    if ret_type.kind.value == Type.Kind.VOID.value:
                        line(f&#34;hl_wrapper_call(value, {vargs}, NULL);&#34;)
                    elif is_ptr(ret_type.kind.value):
                        line(f&#34;return hl_wrapper_call(value, {vargs}, NULL);&#34;)
                    else:
                        line(&#34;vdynamic ret;&#34;)
                        line(f&#34;hl_wrapper_call(value, {vargs}, &amp;ret);&#34;)
                        line(f&#34;return ret.v.{get_wrap_char(ret_type)};&#34;)
                line(&#34;}&#34;)

    line(&#34;&#34;)

    # --- 4. Generate hlc_get_wrapper ---
    line(&#34;void *hlc_get_wrapper( hl_type *t ) {&#34;)
    with indent:
        line(&#34;int chk = TKIND[t-&gt;fun-&gt;ret-&gt;kind];&#34;)
        line(&#34;switch( t-&gt;fun-&gt;nargs ) {&#34;)

        for nargs in sorted_arg_counts:
            line(f&#34;case {nargs}:&#34;)
            with indent:
                if nargs &gt; 9:
                    line(&#39;hl_fatal(&#34;Too many arguments, TODO:use more bits&#34;);&#39;)
                else:
                    for i in range(nargs):
                        line(f&#34;chk |= TKIND[t-&gt;fun-&gt;args[{i}]-&gt;kind] &lt;&lt; {(i + 1) * 3};&#34;)
                    line(&#34;switch( chk ) {&#34;)

                    signatures = fun_by_args[nargs]
                    for (arg_kinds, ret_kind), _ in signatures.items():
                        all_kinds = [ret_kind] + list(arg_kinds)
                        chk_val = sum(get_type_kind_id(kind) &lt;&lt; (i * 3) for i, kind in enumerate(all_kinds))
                        line(f&#34;case {chk_val}:&#34;)
                        with indent:
                            found_sig = False
                            for f in code.functions + code.natives:
                                f_def = f.type.resolve(code).definition
                                if isinstance(f_def, Fun) and len(f_def.args) == nargs:
                                    current_arg_types = [t.resolve(code) for t in f_def.args]
                                    current_ret_type = f_def.ret.resolve(code)
                                    if (
                                        tuple(get_type_kind(t) for t in current_arg_types) == arg_kinds
                                        and get_type_kind(current_ret_type) == ret_kind
                                    ):
                                        wrap_name = make_wrap_name(current_arg_types, current_ret_type)
                                        line(f&#34;return wrap_{wrap_name};&#34;)
                                        found_sig = True
                                        break
                            if not found_sig:
                                line(&#34;/* Wrapper not found for this case */&#34;)
                    line(&#34;}&#34;)
                    line(&#34;break;&#34;)
        line(&#34;}&#34;)
        line(&#34;return NULL;&#34;)
    line(&#34;}&#34;)
    return res</code></pre>
</details>
<div class="desc"><p>Generates the C reflection helpers: hlc_static_call and the function wrappers.</p></div>
</dd>
<dt id="crashlink.hlc.generate_structs"><code class="name flex">
<span>def <span class="ident">generate_structs</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_structs(code: Bytecode) -&gt; List[str]:
    &#34;&#34;&#34;Generates C struct forward declarations and definitions for Haxe classes.&#34;&#34;&#34;
    res = []
    indent = Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    types = code.types
    struct_map = {i: t for i, t in enumerate(types) if isinstance(t.definition, (Struct, Obj))}
    if not struct_map:
        return res

    line(&#34;// Class/Struct forward definitions&#34;)
    for i in sorted(struct_map.keys()):
        dfn = struct_map[i].definition
        assert isinstance(dfn, (Obj, Struct)), f&#34;Expected definition to be Obj or Struct, got {type(dfn).__name__}.&#34;
        line(f&#34;typedef struct _obj${i} *obj${i}; /* {dfn.name.resolve(code)} */&#34;)
    res.append(&#34;&#34;)

    line(&#34;// Class/Struct definitions&#34;)
    for i, typ in tqdm(sorted(struct_map.items())) if USE_TQDM else sorted(struct_map.items()):  # pyright: ignore[reportPossiblyUnboundVariable]
        df = typ.definition
        assert isinstance(df, (Obj, Struct)), f&#34;Expected definition to be Obj or Struct, got {type(df).__name__}.&#34;
        line(f&#34;struct _obj${i} {{ /* {df.name.resolve(code)} */&#34;)
        with indent:
            line(&#34;hl_type *$type;&#34;)
            for f in df.resolve_fields(code):
                field_type = ctype(code, f.type.resolve(code), f.type.value)
                # A STRUCT FIELD IS A C IDENTIFIER, SO IT MUST BE SANITIZED.
                field_name = sanitize_ident(f.name.resolve(code))
                line(f&#34;{field_type} {field_name};&#34;)
        line(&#34;};&#34;)
    return res</code></pre>
</details>
<div class="desc"><p>Generates C struct forward declarations and definitions for Haxe classes.</p></div>
</dd>
<dt id="crashlink.hlc.generate_types"><code class="name flex">
<span>def <span class="ident">generate_types</span></span>(<span>code: Bytecode) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_types(code: Bytecode) -&gt; List[str]:
    &#34;&#34;&#34;Generates the C data and initializers for all hl_type instances.&#34;&#34;&#34;
    res = []
    indent = Indenter()

    def line(*args: Any) -&gt; None:
        res.append(indent.current_indent + &#34; &#34;.join(str(arg) for arg in args))

    types = code.types

    line(&#34;// Type shells&#34;)
    for i, typ in tqdm(enumerate(types), desc=&#34;Generating type shells&#34;) if USE_TQDM else enumerate(types):  # pyright: ignore[reportPossiblyUnboundVariable]
        line(f&#34;hl_type t${i} = {{ {KIND_SHELLS[typ.kind.value]} }};&#34;)

    line(&#34;\n// Type data&#34;)
    for i, typ in tqdm(enumerate(types), desc=&#34;Generating types&#34;) if USE_TQDM else enumerate(types):  # pyright: ignore[reportPossiblyUnboundVariable]
        df = typ.definition
        if isinstance(df, (Obj, Struct)):
            if df.fields:
                vals = &#34;, &#34;.join(
                    f&#39;{{(const uchar*)USTR(&#34;{f.name.resolve(code)}&#34;), &amp;t${f.type.value}, {hl_hash_utf8(f.name.resolve(code))}}}&#39;
                    for f in df.fields
                )
                line(f&#34;static hl_obj_field fieldst${i}[] = {{{vals}}};&#34;)
            if df.protos:
                vals = &#34;, &#34;.join(
                    f&#39;{{(const uchar*)USTR(&#34;{p.name.resolve(code)}&#34;), {p.findex.value}, {p.pindex.value}, {hl_hash_utf8(p.name.resolve(code))}}}&#39;
                    for p in df.protos
                )
                line(f&#34;static hl_obj_proto protot${i}[] = {{{vals}}};&#34;)
            if df.bindings:
                bindings = &#34;, &#34;.join(f&#34;{b.field.value}, {b.findex.value}&#34; for b in df.bindings)
                line(f&#34;static int bindingst${i}[] = {{{bindings}}};&#34;)
            line(f&#34;static hl_type_obj objt${i} = {{&#34;)
            with indent:
                line(f&#34;{df.nfields}, {df.nprotos}, {df.nbindings},&#34;)
                line(f&#39;(const uchar*)USTR(&#34;{df.name.resolve(code)}&#34;),&#39;)
                line(f&#34;&amp;t${df.super.value},&#34; if df.super.value &gt;= 0 else &#34;NULL,&#34;)
                line(f&#34;fieldst${i},&#34; if df.fields else &#34;NULL,&#34;)
                line(f&#34;protot${i},&#34; if df.protos else &#34;NULL,&#34;)
                line(f&#34;bindingst${i},&#34; if df.bindings else &#34;NULL,&#34;)
            line(&#34;};&#34;)
        elif isinstance(df, Fun):
            if df.args:
                line(f&#34;static hl_type *fargst${i}[] = {{{&#39;, &#39;.join(f&#39;&amp;t${arg.value}&#39; for arg in df.args)}}};&#34;)
                line(f&#34;static hl_type_fun tfunt${i} = {{fargst${i}, &amp;t${df.ret.value}, {df.nargs}}};&#34;)
            else:
                line(f&#34;static hl_type_fun tfunt${i} = {{NULL, &amp;t${df.ret.value}, 0}};&#34;)
        elif isinstance(df, Virtual):
            if df.fields:
                vals = &#34;, &#34;.join(
                    f&#39;{{(const uchar*)USTR(&#34;{f.name.resolve(code)}&#34;), &amp;t${f.type.value}, {hl_hash_utf8(f.name.resolve(code))}}}&#39;
                    for f in df.fields
                )
                line(f&#34;static hl_obj_field vfieldst${i}[] = {{{vals}}};&#34;)
                line(f&#34;static hl_type_virtual virtt${i} = {{vfieldst${i}, {df.nfields}}};&#34;)
            else:
                line(f&#34;static hl_type_virtual virtt${i} = {{NULL, 0}};&#34;)
        elif isinstance(df, Enum):
            for cid, constr in enumerate(df.constructs):
                if constr.params:
                    param_types_str = &#34;, &#34;.join(f&#34;&amp;t${p.value}&#34; for p in constr.params)
                    line(f&#34;static hl_type *econstruct_params_{i}_{cid}[] = {{{param_types_str}}};&#34;)
                    offsets_str = &#34;, &#34;.join(&#34;0&#34; for _ in constr.params)
                    line(f&#34;static int econstruct_offsets_{i}_{cid}[] = {{{offsets_str}}};&#34;)

            if df.constructs:
                construct_data_list = []
                for cid, constr in enumerate(df.constructs):
                    constr_name_str = constr.name.resolve(code)
                    nparams = len(constr.params)
                    has_params = nparams &gt; 0

                    # OCaml uses `sizeof(venum)` if no params, but that&#39;s equivalent to 0 for `size`.
                    # The `size` field in `hl_enum_construct` is used differently by the runtime.
                    # We will follow the OCaml&#39;s output which seems to be sizeof(the_constructor_struct)
                    # For now, let&#39;s use 0 for simplicity as the runtime might not need it for boot.
                    # A more correct implementation would require generating the constructor struct first.
                    # Let&#39;s use 0, as this field is mainly for the JIT.
                    size_str = &#34;0&#34;

                    has_ptr = any(is_gc_ptr(p.resolve(code)) for p in constr.params)

                    construct_entry = (
                        f&#39;{{(const uchar*)USTR(&#34;{constr_name_str}&#34;), {nparams}, &#39;
                        f&#34;{&#39;econstruct_params_&#39; + str(i) + &#39;_&#39; + str(cid) if has_params else &#39;NULL&#39;}, &#34;
                        f&#34;{size_str}, {&#39;true&#39; if has_ptr else &#39;false&#39;}, &#34;
                        f&#34;{&#39;econstruct_offsets_&#39; + str(i) + &#39;_&#39; + str(cid) if has_params else &#39;NULL&#39;}}}&#34;
                    )
                    construct_data_list.append(construct_entry)

                line(f&#34;static hl_enum_construct econstructs{i}[] = {{{&#39;, &#39;.join(construct_data_list)}}};&#34;)

            line(f&#34;static hl_type_enum enumt${i} = {{&#34;)
            with indent:
                enum_name = df.name.resolve(code)
                line(f&#39;(const uchar*)USTR(&#34;{enum_name}&#34;),&#39;)
                line(f&#34;{df.nconstructs},&#34;)
                line(f&#34;econstructs{i}&#34; if df.constructs else &#34;NULL&#34;)
            line(&#34;};&#34;)

    return res</code></pre>
</details>
<div class="desc"><p>Generates the C data and initializers for all hl_type instances.</p></div>
</dd>
<dt id="crashlink.hlc.hash_string"><code class="name flex">
<span>def <span class="ident">hash_string</span></span>(<span>s: str) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_string(s: str) -&gt; int:
    &#34;&#34;&#34;Hash a string by encoding it as UTF-8 bytes&#34;&#34;&#34;
    return hl_hash(s.encode(&#34;utf-8&#34;))</code></pre>
</details>
<div class="desc"><p>Hash a string by encoding it as UTF-8 bytes</p></div>
</dd>
<dt id="crashlink.hlc.hl_hash"><code class="name flex">
<span>def <span class="ident">hl_hash</span></span>(<span>name: bytes) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hl_hash(name: bytes) -&gt; int:
    &#34;&#34;&#34;General hash function - processes until null terminator&#34;&#34;&#34;
    h = 0
    for byte_val in name:
        if byte_val == 0:
            break
        h = (223 * h + byte_val) &amp; 0xFFFFFFFF
    h = h % 0x1FFFFF7B
    return h if h &lt; 0x7FFFFFFF else h - 0x100000000</code></pre>
</details>
<div class="desc"><p>General hash function - processes until null terminator</p></div>
</dd>
<dt id="crashlink.hlc.hl_hash_utf8"><code class="name flex">
<span>def <span class="ident">hl_hash_utf8</span></span>(<span>name: str) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hl_hash_utf8(name: str) -&gt; int:
    &#34;&#34;&#34;Hash UTF-8 string until null terminator&#34;&#34;&#34;
    h = 0
    for char in name:
        char_val = ord(char)
        if char_val == 0:
            break
        h = (223 * h + char_val) &amp; 0xFFFFFFFF
    h = h % 0x1FFFFF7B
    return h if h &lt; 0x7FFFFFFF else h - 0x100000000</code></pre>
</details>
<div class="desc"><p>Hash UTF-8 string until null terminator</p></div>
</dd>
<dt id="crashlink.hlc.is_gc_ptr"><code class="name flex">
<span>def <span class="ident">is_gc_ptr</span></span>(<span>typ: Type) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_gc_ptr(typ: Type) -&gt; bool:
    &#34;&#34;&#34;Checks if a type is a pointer that the GC needs to track.&#34;&#34;&#34;
    NON_GC_POINTER_KINDS = {
        Type.Kind.VOID.value,
        Type.Kind.U8.value,
        Type.Kind.U16.value,
        Type.Kind.I32.value,
        Type.Kind.I64.value,
        Type.Kind.F32.value,
        Type.Kind.F64.value,
        Type.Kind.BOOL.value,
        Type.Kind.TYPETYPE.value,
        Type.Kind.REF.value,
        Type.Kind.METHOD.value,
        Type.Kind.PACKED.value,
    }
    return typ.kind.value not in NON_GC_POINTER_KINDS</code></pre>
</details>
<div class="desc"><p>Checks if a type is a pointer that the GC needs to track.</p></div>
</dd>
<dt id="crashlink.hlc.is_ptr"><code class="name flex">
<span>def <span class="ident">is_ptr</span></span>(<span>kind: int) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ptr(kind: int) -&gt; bool:
    &#34;&#34;&#34;Checks if a type kind represents a pointer.&#34;&#34;&#34;
    return kind not in {
        Type.Kind.VOID.value,
        Type.Kind.U8.value,
        Type.Kind.U16.value,
        Type.Kind.I32.value,
        Type.Kind.I64.value,
        Type.Kind.F32.value,
        Type.Kind.F64.value,
        Type.Kind.BOOL.value,
    }</code></pre>
</details>
<div class="desc"><p>Checks if a type kind represents a pointer.</p></div>
</dd>
<dt id="crashlink.hlc.sanitize_ident"><code class="name flex">
<span>def <span class="ident">sanitize_ident</span></span>(<span>name: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sanitize_ident(name: str) -&gt; str:
    &#34;&#34;&#34;
    Sanitizes a Haxe identifier to ensure it&#39;s a valid C identifier.
    If the name is a C keyword or starts with &#39;__&#39;, it&#39;s prefixed with &#39;_hx_&#39;.
    &#34;&#34;&#34;
    if name in KEYWORDS or name.startswith(&#34;__&#34;):
        return &#34;_hx_&#34; + name
    return name</code></pre>
</details>
<div class="desc"><p>Sanitizes a Haxe identifier to ensure it's a valid C identifier.
If the name is a C keyword or starts with '__', it's prefixed with '<em>hx</em>'.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="crashlink.hlc.Indenter"><code class="flex name class">
<span>class <span class="ident">Indenter</span></span>
<span>(</span><span>indent_char: str = '
')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Indenter:
    &#34;&#34;&#34;A context manager for dynamically handling indentation levels.&#34;&#34;&#34;

    indent_char: str
    level: int
    current_indent: str

    def __init__(self, indent_char: str = &#34;    &#34;) -&gt; None:
        self.indent_char = indent_char
        self.level = 0
        self.current_indent = &#34;&#34;

    def __enter__(self) -&gt; &#34;Indenter&#34;:
        self.level += 1
        self.current_indent = self.indent_char * self.level
        return self

    def __exit__(self, exc_type: Optional[Any], exc_val: Optional[Any], exc_tb: Optional[Any]) -&gt; Literal[False]:
        self.level -= 1
        self.current_indent = self.indent_char * self.level
        return False</code></pre>
</details>
<div class="desc"><p>A context manager for dynamically handling indentation levels.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="crashlink.hlc.Indenter.current_indent"><code class="name">var <span class="ident">current_indent</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="crashlink.hlc.Indenter.indent_char"><code class="name">var <span class="ident">indent_char</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="crashlink.hlc.Indenter.level"><code class="name">var <span class="ident">level</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="crashlink" href="index.html">crashlink</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="crashlink.hlc.cast_fun" href="#crashlink.hlc.cast_fun">cast_fun</a></code></li>
<li><code><a title="crashlink.hlc.code_to_c" href="#crashlink.hlc.code_to_c">code_to_c</a></code></li>
<li><code><a title="crashlink.hlc.ctype" href="#crashlink.hlc.ctype">ctype</a></code></li>
<li><code><a title="crashlink.hlc.ctype_no_ptr" href="#crashlink.hlc.ctype_no_ptr">ctype_no_ptr</a></code></li>
<li><code><a title="crashlink.hlc.dyn_value_field" href="#crashlink.hlc.dyn_value_field">dyn_value_field</a></code></li>
<li><code><a title="crashlink.hlc.generate_entry" href="#crashlink.hlc.generate_entry">generate_entry</a></code></li>
<li><code><a title="crashlink.hlc.generate_function_tables" href="#crashlink.hlc.generate_function_tables">generate_function_tables</a></code></li>
<li><code><a title="crashlink.hlc.generate_functions" href="#crashlink.hlc.generate_functions">generate_functions</a></code></li>
<li><code><a title="crashlink.hlc.generate_globals" href="#crashlink.hlc.generate_globals">generate_globals</a></code></li>
<li><code><a title="crashlink.hlc.generate_hashes" href="#crashlink.hlc.generate_hashes">generate_hashes</a></code></li>
<li><code><a title="crashlink.hlc.generate_natives" href="#crashlink.hlc.generate_natives">generate_natives</a></code></li>
<li><code><a title="crashlink.hlc.generate_reflection" href="#crashlink.hlc.generate_reflection">generate_reflection</a></code></li>
<li><code><a title="crashlink.hlc.generate_structs" href="#crashlink.hlc.generate_structs">generate_structs</a></code></li>
<li><code><a title="crashlink.hlc.generate_types" href="#crashlink.hlc.generate_types">generate_types</a></code></li>
<li><code><a title="crashlink.hlc.hash_string" href="#crashlink.hlc.hash_string">hash_string</a></code></li>
<li><code><a title="crashlink.hlc.hl_hash" href="#crashlink.hlc.hl_hash">hl_hash</a></code></li>
<li><code><a title="crashlink.hlc.hl_hash_utf8" href="#crashlink.hlc.hl_hash_utf8">hl_hash_utf8</a></code></li>
<li><code><a title="crashlink.hlc.is_gc_ptr" href="#crashlink.hlc.is_gc_ptr">is_gc_ptr</a></code></li>
<li><code><a title="crashlink.hlc.is_ptr" href="#crashlink.hlc.is_ptr">is_ptr</a></code></li>
<li><code><a title="crashlink.hlc.sanitize_ident" href="#crashlink.hlc.sanitize_ident">sanitize_ident</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="crashlink.hlc.Indenter" href="#crashlink.hlc.Indenter">Indenter</a></code></h4>
<ul class="">
<li><code><a title="crashlink.hlc.Indenter.current_indent" href="#crashlink.hlc.Indenter.current_indent">current_indent</a></code></li>
<li><code><a title="crashlink.hlc.Indenter.indent_char" href="#crashlink.hlc.Indenter.indent_char">indent_char</a></code></li>
<li><code><a title="crashlink.hlc.Indenter.level" href="#crashlink.hlc.Indenter.level">level</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
